<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dashboard | Learning Scheduler</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<script src="https://tklesson.com/resources-loader.js"></script>
<script>loadCommonResources();</script>

<!-- Firebase SDKs - Using compat version for easier integration -->
<script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-functions-compat.js"></script>

<style>

/* ============================================= */
/* BEAUTIFUL DASHBOARD ENHANCEMENTS */
/* ============================================= */

/* Enhanced Color Palette with Modern Gradients */
:root {
  --primary: #6C63FF;
  --primary-light: #8A84FF;
  --primary-dark: #554FD8;
  --secondary: #FF6584;
  --accent: #FF9A3D;
  --accent-light: #FFB366;
  --light: #FAFBFF;
  --dark: #2D3748;
  --dark-light: #4A5568;
  --success: #4ADE80;
  --success-light: #73E8A2;
  --error: #F87171;
  --warning: #FBBF24;
  --gray: #94A3B8;
  --gray-light: #F1F5F9;
  --border-radius: 20px;
  --border-radius-sm: 12px;
  --box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
  --box-shadow-hover: 0 20px 50px rgba(0, 0, 0, 0.12);
  --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.1);
  --glass-bg: rgba(255, 255, 255, 0.15);
  --glass-border: rgba(255, 255, 255, 0.2);
  --card-gradient: linear-gradient(145deg, #ffffff, #f8faff);
}

/* Enhanced Global Styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(135deg, #f5f7ff 0%, #f0f4ff 100%);
  min-height: 100vh;
  color: var(--dark);
  line-height: 1.7;
  overflow-x: hidden;
}

/* Enhanced Dashboard Container */
.dashboard-container {
  display: flex;
  min-height: 100vh;
  background: transparent;
}

/* Glassmorphism Sidebar */
.sidebar {
  width: 300px;
  background: linear-gradient(180deg, var(--primary) 0%, var(--primary-dark) 100%);
  color: white;
  position: fixed;
  height: 100vh;
  overflow-y: auto;
  transition: var(--transition);
  z-index: 1000;
  box-shadow: var(--box-shadow);
  backdrop-filter: blur(10px);
  border-right: 1px solid var(--glass-border);
}

.sidebar-header {
  padding: 30px 25px;
  border-bottom: 1px solid var(--glass-border);
  background: rgba(255, 255, 255, 0.05);
}

.logo {
  display: flex;
  align-items: center;
  margin-bottom: 30px;
  transition: var(--transition);
}

.logo:hover {
  transform: translateY(-2px);
}

.logo img {
  width: 45px;
  height: 45px;
  margin-right: 15px;
  object-fit: contain;
  filter: brightness(0) invert(1);
}

.logo h1 {
  font-size: 24px;
  font-weight: 700;
  background: linear-gradient(90deg, #ffffff, #e2e8ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.user-info {
  display: flex;
  align-items: center;
  padding: 15px;
  border-radius: var(--border-radius-sm);
  background: var(--glass-bg);
  backdrop-filter: blur(10px);
  transition: var(--transition);
}

.user-info:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.user-avatar {
  width: 55px;
  height: 55px;
  background: var(--glass-bg);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 15px;
  font-size: 22px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  transition: var(--transition);
}

.user-avatar:hover {
  transform: scale(1.05);
  border-color: rgba(255, 255, 255, 0.5);
}

.user-details h3 {
  font-size: 16px;
  margin-bottom: 5px;
  font-weight: 600;
}

.user-details p {
  font-size: 13px;
  opacity: 0.9;
}

/* Enhanced Sidebar Menu */
.sidebar-menu {
  list-style: none;
  padding: 20px 0;
}

.menu-item {
  margin-bottom: 5px;
  position: relative;
}

.menu-item a {
  display: flex;
  align-items: center;
  padding: 16px 25px;
  color: rgba(255, 255, 255, 0.85);
  text-decoration: none;
  transition: var(--transition);
  font-weight: 500;
  position: relative;
  overflow: hidden;
}

.menu-item a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transition: left 0.6s;
}

.menu-item a:hover::before {
  left: 100%;
}

.menu-item a:hover, .menu-item a.active {
  background: var(--glass-bg);
  color: white;
  border-left: 4px solid var(--accent);
  transform: translateX(5px);
}

.menu-item i {
  margin-right: 15px;
  font-size: 20px;
  width: 24px;
  text-align: center;
  transition: var(--transition);
}

.menu-item a:hover i {
  transform: scale(1.1);
  color: var(--accent);
}

.menu-badge {
  background: var(--accent);
  color: white;
  border-radius: 20px;
  padding: 4px 10px;
  font-size: 0.75em;
  font-weight: 600;
  margin-left: auto;
  animation: gentle-pulse 2s infinite;
}

/* Enhanced Main Content */
.main-content {
  flex: 1;
  margin-left: 300px;
  padding: 30px;
  transition: var(--transition);
  background: transparent;
}

/* Enhanced Top Bar */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
  background: white;
  padding: 20px 30px;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.8);
  transition: var(--transition);
}

.top-bar:hover {
  box-shadow: var(--box-shadow-hover);
  transform: translateY(-2px);
}

.page-title h2 {
  font-size: 28px;
  font-weight: 700;
  color: var(--primary-dark);
  margin-bottom: 5px;
  background: linear-gradient(90deg, var(--primary), var(--primary-light));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.page-title p {
  color: var(--gray);
  font-size: 15px;
}

.top-bar-actions {
  display: flex;
  align-items: center;
  gap: 20px;
}

/* Enhanced Notification Bell */
.notification-btn {
  position: relative;
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background: var(--gray-light);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--transition);
  color: var(--dark);
}

.notification-btn:hover {
  background: var(--primary);
  color: white;
  transform: scale(1.1) rotate(10deg);
}

.notification-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background: var(--accent);
  color: white;
  font-size: 11px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  animation: gentle-pulse 2s infinite;
  box-shadow: 0 2px 10px rgba(255, 154, 61, 0.5);
}

/* Enhanced Logout Button */
.logout-btn {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  border: none;
  padding: 12px 20px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 10px;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(108, 99, 255, 0.3);
}

.logout-btn:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.4);
}

/* Enhanced Stats Container */
.stats-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 25px;
  margin-bottom: 40px;
}

.stat-card {
  background: var(--card-gradient);
  padding: 30px;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  display: flex;
  flex-direction: column;
  transition: var(--transition);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.8);
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 5px;
  background: linear-gradient(90deg, var(--primary), var(--accent));
}

.stat-card:hover {
  transform: translateY(-8px);
  box-shadow: var(--box-shadow-hover);
}

.stat-icon {
  width: 70px;
  height: 70px;
  border-radius: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
  font-size: 28px;
  transition: var(--transition);
}

.stat-card:hover .stat-icon {
  transform: scale(1.1) rotate(5deg);
}

.stat-icon.blue {
  background: linear-gradient(135deg, rgba(108, 99, 255, 0.1), rgba(108, 99, 255, 0.2));
  color: var(--primary);
  box-shadow: 0 5px 15px rgba(108, 99, 255, 0.2);
}

.stat-icon.green {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(74, 222, 128, 0.2));
  color: var(--success);
  box-shadow: 0 5px 15px rgba(74, 222, 128, 0.2);
}

.stat-icon.pink {
  background: linear-gradient(135deg, rgba(255, 101, 132, 0.1), rgba(255, 101, 132, 0.2));
  color: var(--secondary);
  box-shadow: 0 5px 15px rgba(255, 101, 132, 0.2);
}

.stat-value {
  font-size: 36px;
  font-weight: 800;
  margin-bottom: 10px;
  background: linear-gradient(90deg, var(--primary-dark), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.stat-label {
  color: var(--gray);
  font-size: 15px;
  font-weight: 500;
}

/* Enhanced Dashboard Sections */
.dashboard-section {
  display: none;
  background: white;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  padding: 30px;
  margin-bottom: 40px;
  transition: var(--transition);
  border: 1px solid rgba(255, 255, 255, 0.8);
}

.dashboard-section.active {
  display: block;
  animation: fadeInUp 0.6s ease;
}

.section-header {
  display: flex;
  align-items: center;
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px solid var(--gray-light);
}

.section-header h3 {
  font-size: 24px;
  font-weight: 700;
  color: var(--primary-dark);
  display: flex;
  align-items: center;
  gap: 15px;
}

.section-header h3 i {
  color: var(--primary);
  font-size: 26px;
}

/* Enhanced Profile Card */
.profile-card {
  display: flex;
  align-items: center;
  background: linear-gradient(135deg, #f8faff, #ffffff);
  padding: 30px;
  border-radius: var(--border-radius);
  margin-bottom: 30px;
  box-shadow: var(--box-shadow);
  transition: var(--transition);
  border: 1px solid rgba(255, 255, 255, 0.8);
}

.profile-card:hover {
  transform: translateY(-5px);
  box-shadow: var(--box-shadow-hover);
}

.profile-avatar {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;
  margin-right: 25px;
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.3);
  transition: var(--transition);
}

.profile-card:hover .profile-avatar {
  transform: scale(1.05);
}

.profile-details {
  flex: 1;
}

.profile-details h3 {
  font-size: 24px;
  margin-bottom: 10px;
  color: var(--dark);
}

.profile-details p {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
  color: var(--gray);
  font-size: 15px;
}

.status-badge {
  display: inline-block;
  padding: 6px 15px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  margin-top: 10px;
}

.status-verified {
  background: rgba(74, 222, 128, 0.1);
  color: var(--success);
  border: 1px solid rgba(74, 222, 128, 0.3);
}

.status-pending {
  background: rgba(251, 191, 36, 0.1);
  color: var(--warning);
  border: 1px solid rgba(251, 191, 36, 0.3);
}

.edit-profile-btn {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  border: none;
  padding: 12px 25px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(108, 99, 255, 0.3);
}

.edit-profile-btn:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.4);
}

/* Enhanced Forms */
.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 25px;
  margin-bottom: 25px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 10px;
  font-weight: 600;
  color: var(--dark);
  font-size: 15px;
}

.form-control {
  width: 100%;
  padding: 15px 20px;
  border: 1px solid var(--gray-light);
  border-radius: var(--border-radius-sm);
  font-family: 'Poppins', sans-serif;
  transition: var(--transition);
  background: white;
  font-size: 15px;
}

.form-control:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.1);
  transform: translateY(-2px);
}

.save-btn {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  border: none;
  padding: 15px 30px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(108, 99, 255, 0.3);
}

.save-btn:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.4);
}

/* Enhanced Buttons */
.btn-primary {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(108, 99, 255, 0.3);
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-primary:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.4);
}

.btn-outline {
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
  padding: 10px 22px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-outline:hover {
  background: var(--primary);
  color: white;
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(108, 99, 255, 0.3);
}

.btn-success {
  background: linear-gradient(135deg, var(--success), var(--success-light));
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(74, 222, 128, 0.3);
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-success:hover {
  background: linear-gradient(135deg, var(--success), #3ac46c);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(74, 222, 128, 0.4);
}

.btn-danger {
  background: linear-gradient(135deg, var(--error), #f75252);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: 0 4px 15px rgba(248, 113, 113, 0.3);
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-danger:hover {
  background: linear-gradient(135deg, var(--error), #e63c3c);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(248, 113, 113, 0.4);
}

/* Enhanced Cards */
.session-card, .tutor-card, .package-card, .review-card {
  background: var(--card-gradient);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  padding: 25px;
  margin-bottom: 20px;
  transition: var(--transition);
  border: 1px solid rgba(255, 255, 255, 0.8);
  position: relative;
  overflow: hidden;
}

.session-card::before, .tutor-card::before, .package-card::before, .review-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 5px;
  height: 100%;
  background: linear-gradient(180deg, var(--primary), var(--accent));
}

.session-card:hover, .tutor-card:hover, .package-card:hover, .review-card:hover {
  transform: translateY(-5px);
  box-shadow: var(--box-shadow-hover);
}

/* Enhanced Chat System */
.chat-section {
  background: white;
  border-radius: var(--border-radius);
  padding: 0;
  box-shadow: var(--box-shadow);
  overflow: hidden;
  display: none;
  border: 1px solid rgba(255, 255, 255, 0.8);
}

.chat-section.active {
  display: block;
  animation: fadeIn 0.5s ease;
}

.chat-header {
  padding: 25px 30px;
  border-bottom: 1px solid var(--gray-light);
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
}

.chat-header h3 {
  margin: 0;
  font-size: 22px;
  display: flex;
  align-items: center;
  gap: 15px;
}

.chat-container {
  display: flex;
  height: 600px;
}

/* Enhanced Reviews Section */
.reviews-container {
  display: flex;
  flex-direction: column;
  gap: 30px;
}

.pending-reviews-section, .submitted-reviews-section {
  background: white;
  border-radius: var(--border-radius);
  padding: 30px;
  box-shadow: var(--box-shadow);
  transition: var(--transition);
  border: 1px solid rgba(255, 255, 255, 0.8);
}

.pending-reviews-section:hover, .submitted-reviews-section:hover {
  transform: translateY(-3px);
  box-shadow: var(--box-shadow-hover);
}

.reviews-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 25px;
  padding-bottom: 20px;
  border-bottom: 1px solid var(--gray-light);
}

.reviews-section-header h4 {
  margin: 0;
  color: var(--primary-dark);
  font-size: 20px;
  font-weight: 600;
}

.reviews-count-badge {
  background: linear-gradient(135deg, var(--accent), var(--accent-light));
  color: white;
  padding: 6px 15px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 600;
  box-shadow: 0 4px 15px rgba(255, 154, 61, 0.3);
}

/* Enhanced Package Store */
.package-balance-card {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  color: white;
  border-radius: var(--border-radius);
  padding: 30px;
  margin-bottom: 40px;
  box-shadow: var(--box-shadow);
  transition: var(--transition);
  position: relative;
  overflow: hidden;
}

.package-balance-card::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
  transform: rotate(30deg);
}

.package-balance-card:hover {
  transform: translateY(-5px);
  box-shadow: var(--box-shadow-hover);
}

.balance-header h3 {
  margin: 0 0 20px 0;
  font-size: 22px;
  font-weight: 600;
}

.balance-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
}

.balance-item {
  display: flex;
  flex-direction: column;
}

.package-name {
  font-weight: 600;
  font-size: 16px;
  opacity: 0.9;
  margin-bottom: 8px;
}

.session-count {
  font-size: 32px;
  font-weight: 800;
}

.packages-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 25px;
  margin-top: 30px;
}

.package-card.featured {
  border: 2px solid var(--primary);
  transform: scale(1.02);
  box-shadow: 0 15px 40px rgba(108, 99, 255, 0.2);
}

.package-badge {
  position: absolute;
  top: -10px;
  right: 20px;
  background: linear-gradient(135deg, var(--accent), var(--accent-light));
  color: white;
  padding: 6px 18px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: bold;
  box-shadow: 0 4px 15px rgba(255, 154, 61, 0.4);
}

.package-header {
  text-align: center;
  margin-bottom: 25px;
}

.package-header h3 {
  margin: 0 0 15px 0;
  color: var(--dark);
  font-size: 22px;
  font-weight: 700;
}

.package-price {
  font-size: 36px;
  font-weight: 800;
  color: var(--primary);
}

.package-features {
  margin: 25px 0;
}

.feature {
  display: flex;
  align-items: center;
  margin-bottom: 15px;
  color: var(--dark-light);
  font-size: 15px;
}

.feature i {
  color: var(--success);
  margin-right: 12px;
  font-size: 16px;
}

.btn-full {
  width: 100%;
  padding: 15px;
  font-size: 16px;
  font-weight: 600;
}

/* Enhanced Animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes gentle-pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Enhanced Responsive Design */
@media (max-width: 1024px) {
  .sidebar {
    width: 260px;
  }

  .main-content {
    margin-left: 260px;
    padding: 25px;
  }

  .form-row {
    grid-template-columns: 1fr;
  }
  
  .stats-container {
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  }
}

@media (max-width: 768px) {
  .menu-toggle {
    display: flex !important;
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1100;
    background: var(--primary);
    color: white;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: var(--box-shadow);
    transition: var(--transition);
  }
  
  .menu-toggle:hover {
    transform: scale(1.1);
  }

  .sidebar {
    transform: translateX(-100%);
  }

  .sidebar.active {
    transform: translateX(0);
  }

  .main-content {
    margin-left: 0;
    padding: 80px 20px 30px;
  }

  .top-bar {
    flex-direction: column;
    align-items: flex-start;
    gap: 20px;
    padding: 20px;
  }

  .stats-container {
    grid-template-columns: 1fr;
  }

  .profile-card {
    flex-direction: column;
    text-align: center;
    padding: 25px;
  }

  .profile-avatar {
    margin-right: 0;
    margin-bottom: 20px;
  }

  .tutors-container {
    grid-template-columns: 1fr;
  }

  .session-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }

  .session-actions {
    flex-wrap: wrap;
  }
  
  .packages-grid {
    grid-template-columns: 1fr;
  }
  
  .chat-container {
    flex-direction: column;
    height: 500px;
  }
}

@media (max-width: 480px) {
  .main-content {
    padding: 80px 15px 25px;
  }
  
  .dashboard-section {
    padding: 20px;
  }
  
  .section-header h3 {
    font-size: 20px;
  }
  
  .stat-card {
    padding: 25px;
  }
  
  .stat-value {
    font-size: 30px;
  }
  
  .package-card {
    padding: 20px;
  }
  
  .package-price {
    font-size: 30px;
  }
}

/* Additional Beautiful Enhancements */
.loading-state, .empty-state, .error-state {
  text-align: center;
  padding: 50px 30px;
  color: var(--gray);
  border-radius: var(--border-radius);
  background: var(--card-gradient);
  box-shadow: var(--box-shadow);
  transition: var(--transition);
}

.loading-state:hover, .empty-state:hover, .error-state:hover {
  transform: translateY(-3px);
  box-shadow: var(--box-shadow-hover);
}

.loading-state i, .empty-state i, .error-state i {
  margin-bottom: 20px;
  color: var(--primary-light);
  font-size: 48px;
}

.empty-state i {
  color: var(--gray-light);
}

.error-state i {
  color: var(--error);
}

.empty-state h3, .error-state h3 {
  margin-bottom: 15px;
  color: var(--dark);
  font-size: 22px;
}

/* Enhanced Scrollbars */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--gray-light);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, var(--primary), var(--primary-light));
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--primary));
}

/* Enhanced Focus States */
button:focus, input:focus, textarea:focus, select:focus {
  outline: 2px solid var(--primary-light);
  outline-offset: 2px;
}

/* Enhanced Selection */
::selection {
  background: rgba(108, 99, 255, 0.2);
  color: var(--dark);
}

/* Enhanced Transitions for All Interactive Elements */
a, button, .form-control, .menu-item, .stat-card, .session-card, 
.tutor-card, .package-card, .review-card, .dashboard-section,
.top-bar, .profile-card, .chat-section {
  transition: var(--transition);
}

/* Enhanced Text Selection */
.selectable {
  user-select: text;
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
}

/* Print Styles */
@media print {
  .sidebar, .top-bar-actions, .menu-toggle {
    display: none !important;
  }
  
  .main-content {
    margin-left: 0;
  }
  
  .stat-card, .session-card, .dashboard-section {
    box-shadow: none;
    border: 1px solid #ddd;
  }
}
  
/* ============================================= */
/* PERFORMANCE OPTIMIZATIONS */
/* ============================================= */

.dashboard-section,
.stat-card,
.session-card,
.tutor-card,
.package-card,
.message {
  will-change: transform;
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

</style>
</head>
<body>

<div class="menu-toggle" id="menuToggle">
  <i class="fas fa-bars"></i>
</div>
<!-- Add this inside your chat-header-detail div -->
<div class="chat-mobile-only" id="mobileChatHeader" style="display: none;">
    <div class="chat-back-btn" id="chatBackBtn">
        <i class="fas fa-arrow-left"></i>
        <span>Back</span>
    </div>
</div>
<div class="dashboard-container">
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="logo">
        <img src="Tklesson3.png" alt="Tklesson Logo">
        <h1>Tklesson</h1>
      </div>
      <div class="user-info">
        <div class="user-avatar">
          <i class="fas fa-user"></i>
        </div>
        <div class="user-details">
          <h3 id="userName">Loading...</h3>
          <p id="userRole">Student</p>
        </div>
      </div>
    </div>

    <ul class="sidebar-menu">
      <li class="menu-item">
        <a href="#profile" class="active" data-section="profile">
          <i class="fas fa-user-circle"></i>
          <span>Profile</span>
        </a>
      </li>
 <!-- ADD PACKAGES MENU ITEM HERE -->
      <li class="menu-item">
        <a href="#packages" data-section="packages">
          <i class="fas fa-shopping-cart"></i>
          <span>Packages</span>
        </a>
      </li>
      <!-- END OF PACKAGES MENU ITEM -->

      <li class="menu-item">
        <a href="#scheduling" data-section="scheduling">
          <i class="fas fa-calendar-alt"></i>
          <span>Scheduling</span>
        </a>
      </li>
      <li class="menu-item">
        <a href="#tutors" data-section="tutors">
          <i class="fas fa-user-tie"></i>
          <span>My Tutors</span>
        </a>
      </li>
      <li class="menu-item">
  <a href="#chat" data-section="chat">
    <i class="fas fa-comments"></i>
    <span>Messages</span>
    <span class="menu-badge" id="unreadMessagesCount" style="display: none;">0</span>
  </a>
</li>
      <li class="menu-item">
        <a href="#bookings" data-section="bookings">
          <i class="fas fa-bookmark"></i>
          <span>My Bookings</span>
        </a>
      </li>
<li class="menu-item">
  <a href="#reviews" data-section="reviews">
    <i class="fas fa-star"></i>
    <span>Session Reviews</span>
    <span class="menu-badge" id="pendingReviewsCount" style="display: none;">0</span>
  </a>
</li>
      <li class="menu-item">
        <a href="#sessions" data-section="sessions">
          <i class="fas fa-history"></i>
          <span>Sessions History</span>
        </a>
      </li>
    </ul>
  </aside>

  <main class="main-content">
    <div class="top-bar">
      <div class="page-title">
        <h2>Student Dashboard</h2>
        <p>Welcome back! Here's your learning overview</p>
      </div>
      <div class="top-bar-actions">
  <div class="notification-btn" id="notificationBell">
    <i class="fas fa-bell"></i>
    <span class="notification-badge" id="notificationCount" style="display: none;">0</span>
  </div>
        <button class="logout-btn" id="logoutBtn">
          <i class="fas fa-sign-out-alt"></i> Logout
        </button>
      </div>
    </div>

    <div class="stats-container">
      <div class="stat-card">
        <div class="stat-icon blue">
          <i class="fas fa-bookmark"></i>
        </div>
        <div class="stat-value" id="upcomingSessionsCount">0</div>
        <div class="stat-label">Upcoming Sessions</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon green">
          <i class="fas fa-user-tie"></i>
        </div>
        <div class="stat-value" id="tutorsCount">0</div>
        <div class="stat-label">Active Tutors</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon pink">
          <i class="fas fa-clock"></i>
        </div>
        <div class="stat-value" id="hoursLearned">0</div>
        <div class="stat-label">Hours Learned</div>
      </div>
    </div>

<!-- NEW PACKAGE STORE SECTION - ADD THIS -->
    <section id="packages" class="dashboard-section">
      <div class="section-header">
        <h2><i class="fas fa-shopping-cart"></i> Tutoring Packages</h2>
        <p>Purchase session packages and save</p>
      </div>

      <!-- Package Balance Display -->
      <div class="package-balance-card">
  <div class="balance-header">
    <h3><i class="fas fa-wallet"></i> Your Session Credits</h3>
  </div>
  <div class="balance-content">
    <div class="balance-item">
      <div class="package-name">Available Sessions</div>
      <span class="session-count" id="taiwoBalance">0 sessions</span>
    </div>
    <div class="balance-actions">
      <button class="btn-outline" onclick="loadPurchaseHistory()">
        <i class="fas fa-history"></i> Purchase History
      </button>
    </div>
  </div>
</div>

<!-- Purchase History Section -->
<div class="purchase-history-section" style="margin-top: 30px;">
  <div class="section-header">
    <h3><i class="fas fa-history"></i> Purchase History</h3>
  </div>
  <div id="purchaseHistoryContainer">
    <div class="empty-state">
      <i class="fas fa-receipt"></i>
      <h3>No Purchase History</h3>
      <p>Your package purchases will appear here</p>
    </div>
  </div>
</div>
      
      <!-- Available Packages -->
      <div class="packages-grid">
  <!-- Hourly Package -->
  <div class="package-card">
    <div class="package-header">
      <h3>Hourly Session</h3>
      <div class="package-price">$50</div>
    </div>
    <div class="package-features">
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>1 tutoring session</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>1 hour each</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Valid For 6 Months</span>
      </div>
    </div>
    <button class="btn-primary btn-full" onclick="purchasePackage('hourly')">
      <i class="fas fa-credit-card"></i> Purchase Now
    </button>
  </div>

  <!-- Bronze Package -->
  <div class="package-card">
    <div class="package-header">
      <h3>Bronze Package</h3>
      <div class="package-price">$185</div>
    </div>
    <div class="package-features">
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>4 tutoring sessions</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>1 hour each</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Save $15</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Valid For 6 Months</span>
      </div>
    </div>
    <button class="btn-primary btn-full" onclick="purchasePackage('bronze')">
      <i class="fas fa-credit-card"></i> Purchase Now
    </button>
  </div>

  <!-- Silver Package -->
  <div class="package-card featured">
    <div class="package-badge">Most Popular</div>
    <div class="package-header">
      <h3>Silver Package</h3>
      <div class="package-price">$365</div>
    </div>
    <div class="package-features">
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>8 tutoring sessions</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>1 hour each</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Save $35</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Valid For 6 Months</span>
      </div>
    </div>
    <button class="btn-primary btn-full" onclick="purchasePackage('silver')">
      <i class="fas fa-credit-card"></i> Purchase Now
    </button>
  </div>

  <!-- Gold Package -->
  <div class="package-card">
    <div class="package-header">
      <h3>Gold Package</h3>
      <div class="package-price">$525</div>
    </div>
    <div class="package-features">
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>12 tutoring sessions</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>1 hour each</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Save $75</span>
      </div>
      <div class="feature">
        <i class="fas fa-check"></i>
        <span>Valid For 6 Months</span>
      </div>
    </div>
    <button class="btn-primary btn-full" onclick="purchasePackage('gold')">
      <i class="fas fa-credit-card"></i> Purchase Now
    </button>
  </div>
</div>
    </section>

    <!-- Existing profile section (unchanged) -->
    <section id="profile" class="dashboard-section active">
      <div class="section-header">
        <h3><i class="fas fa-user-circle"></i> Profile Information</h3>
      </div>

      <div class="profile-card">
        <div class="profile-avatar">
          <i class="fas fa-user"></i>
        </div>
        <div class="profile-details">
          <h3 id="profileName">Loading...</h3>
          <p><i class="fas fa-envelope"></i> <span id="profileEmail">Loading...</span></p>
          <p><i class="fas fa-user-tag"></i> <span id="profileRole">Student Account</span></p>
          <span class="status-badge status-verified" id="profileStatus">Verified</span>
        </div>
        <button class="edit-profile-btn" id="editProfileBtn">Edit Profile</button>
      </div>

      <div class="section-header">
        <h3><i class="fas fa-cog"></i> Account Settings</h3>
      </div>

      <form id="profileForm" style="display: none;">
        <div class="form-row">
          <div class="form-group">
            <label for="fullName">Full Name</label>
            <!-- Changed id from "name" to "fullName" -->
            <input type="text" id="fullName" class="form-control">
          </div>
          <div class="form-group">
            <label for="email">Email Address</label>
            <input type="email" id="email" class="form-control" disabled>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="phone">Phone Number</label>
            <input type="tel" id="phone" class="form-control">
          </div>
          <div class="form-group">
            <label for="role">Account Type</label>
            <input type="text" id="role" class="form-control" value="Student" disabled>
          </div>
        </div>
        <button type="button" class="save-btn" id="saveProfileBtn">Save Changes</button>
      </form>
    </section>

    <section id="scheduling" class="dashboard-section">
      <div class="section-header">
        <h3><i class="fas fa-calendar-alt"></i> New Booking</h3>
      </div>
      
      <form id="schedulingForm">
        <div class="form-group">
          <label for="tutor">Select Tutor *</label>
          <select id="tutor" class="form-control" required>
            <option value="">Select a tutor...</option>
            <!-- Tutors will be loaded here -->
          </select>
          <div class="spinner" id="tutorSpinner" style="display: none;"></div>
        </div>
        
        <div class="form-group">
          <label for="subject">Subject *</label>
          <select id="subject" class="form-control" required disabled>
            <option value="">Select a tutor first</option>
          </select>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label for="date">Date *</label>
            <input type="date" id="date" class="form-control" required 
                   min="<?php echo date('Y-m-d'); ?>">
          </div>
          <div class="form-group">
            <label for="time">Time *</label>
            <input type="time" id="time" class="form-control" required 
                   min="5:00" max="23:00">
          </div>
        </div>
        
        <div class="form-row">
  <div class="form-group">
    <label for="duration">Duration *</label>
    <div style="padding: 10px; background: #f5f5f5; border-radius: 4px; border: 1px solid #ddd;">
      <i class="fas fa-clock"></i> 1 hour (fixed)
    </div>
    <input type="hidden" id="duration" name="duration" value="1">
  </div>
  <div class="form-group">
    <label for="sessionType">Session Type *</label>
    <div style="padding: 10px; background: #f5f5f5; border-radius: 4px; border: 1px solid #ddd;">
      <i class="fas fa-video"></i> Online (fixed)
    </div>
    <input type="hidden" id="sessionType" name="sessionType" value="online">
  </div>
</div>
        
        <div class="form-group">
          <label for="notes">Session Notes (Optional)</label>
          <textarea id="notes" class="form-control" rows="4" 
                    placeholder="What would you like to focus on during this session? Any specific topics or areas of difficulty?"></textarea>
        </div>
        
        <div class="form-group" id="priceSummary" style="display: none;">
          <h4>Price Summary</h4>
          <p>Hourly Rate: $<span id="hourlyRate">0</span></p>
          <p>Duration: <span id="durationDisplay">0</span> hours</p>
          <p><strong>Total: $<span id="totalPrice">0</span></strong></p>
        </div>
        
        <button type="submit" class="save-btn" id="scheduleBtn">
          <i class="fas fa-calendar-check"></i> Schedule Session
        </button>
      </form>
    </section>

    <section id="tutors" class="dashboard-section">
      <div class="section-header">
        <h3><i class="fas fa-user-tie"></i> Find Tutors</h3>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="my-tutors">My Tutors</div>
        <div class="tab" data-tab="available-tutors">Available Tutors</div>
      </div>

      <div class="search-container" style="margin-bottom: 20px; display: none;" id="tutorSearchContainer">
        <input type="text" id="tutorSearch" class="form-control" placeholder="Search tutors by name or subject...">
      </div>

      <div class="tab-content active" id="my-tutors-tab">
        <div id="myTutorsContainer">
          <p>Loading your tutors...</p>
        </div>
      </div>

      <div class="tab-content" id="available-tutors-tab">
        <div id="availableTutorsContainer">
          <div class="spinner" id="tutorsSpinner"></div>
        </div>
      </div>
    </section>

<section id="bookings" class="dashboard-section">
    <div class="section-header">
        <h3><i class="fas fa-bookmark"></i> My Bookings</h3>
    </div>
    
    <!-- Add filter for reschedule requests -->
    <div style="margin-bottom: 20px;">
        <label>Filter by:</label>
        <select id="bookingFilter" class="form-control" style="width: 200px;">
            <option value="all">All Bookings</option>
            <option value="upcoming">Upcoming</option>
            <option value="reschedule">Reschedule Requests</option>
            <option value="pending">Pending</option>
        </select>
    </div>
    
    <div id="bookingsContainer">
        <p>Loading your bookings...</p>
    </div>
</section>

<section id="sessions" class="dashboard-section">
  <div class="section-header">
    <h3><i class="fas fa-history"></i> Sessions History</h3>
  </div>
  
  <div style="margin-bottom: 20px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
    <div>
      <label>Filter by:</label>
      <select id="historyFilter" class="form-control" style="width: 200px;">
        <option value="all">All Time</option>
        <option value="month">This Month</option>
        <option value="3months">Last 3 Months</option>
        <option value="year">This Year</option>
      </select>
    </div>
    <div>
      <label>Action Type:</label>
      <select id="actionTypeFilter" class="form-control" style="width: 200px;">
        <option value="all">All Actions</option>
        <option value="student booked">Student Booked</option>
        <option value="tutor confirmed">Tutor Confirmed</option>
        <option value="student confirmed">Student Confirmed</option>
        <option value="auto-confirmed">Auto-Confirmed</option>
        <option value="completed">Completed</option>
        <option value="student cancelled">Student Cancelled</option>
        <option value="tutor cancelled">Tutor Cancelled</option>
        <option value="tutor reschedule request">Tutor Reschedule Request</option>
        <option value="student reschedule request">Student Reschedule Request</option>
        <option value="rescheduled">Rescheduled</option>
      </select>
    </div>
    
    <!-- Add view toggle buttons -->
    <div class="view-toggle" style="margin-left: auto;">
      <button class="view-toggle-btn active" data-view="cards">
        <i class="fas fa-th-large"></i> Cards
      </button>
      <button class="view-toggle-btn" data-view="table">
        <i class="fas fa-table"></i> Table
      </button>
    </div>
  </div>

  <!-- Cards View Container -->
  <div id="sessionsCardsContainer" class="sessions-cards-container">
    <div class="spinner" id="sessionsSpinner"></div>
  </div>

  <!-- Table View Container (existing) -->
  <div id="sessionsTableContainer" style="display: none;">
    <div id="sessionsContainer">
      <div class="spinner"></div>
    </div>
  </div>

  <!-- Pagination Container -->
  <div class="pagination-container" id="paginationContainer" style="display: none;">
    <button class="pagination-btn" id="firstPageBtn" disabled>
      <i class="fas fa-angle-double-left"></i>
    </button>
    <button class="pagination-btn" id="prevPageBtn" disabled>
      <i class="fas fa-angle-left"></i>
    </button>
    
    <div class="pagination-pages" id="pageNumbers"></div>
    
    <button class="pagination-btn" id="nextPageBtn" disabled>
      <i class="fas fa-angle-right"></i>
    </button>
    <button class="pagination-btn" id="lastPageBtn" disabled>
      <i class="fas fa-angle-double-right"></i>
    </button>
    
    <div class="pagination-info" id="paginationInfo"></div>
  </div>
</section>

<section id="chat" class="dashboard-section">
  <div class="section-header">
    <h3><i class="fas fa-comments"></i> Messages</h3>
  </div>
  
  <div class="chat-section active" id="chatContainer">
    <div class="chat-header">
      <h3><i class="fas fa-comments"></i> Messages</h3>
    </div>
    
    <div class="chat-container">
      <!-- Contacts List -->
      <div class="chat-contacts">
        <div class="contact-search">
          <input type="text" id="contactSearch" placeholder="Search tutors...">
        </div>
        <div class="contacts-list" id="contactsList">
          <div class="empty-state">
            <i class="fas fa-comments"></i>
            <h4>No Conversations</h4>
            <p>Start a conversation with your tutors</p>
          </div>
        </div>
      </div>
      
      <!-- Chat Messages Area -->
      <div class="chat-messages">
        <div class="chat-empty-state" id="emptyChatState">
          <i class="fas fa-comments"></i>
          <h4>No Chat Selected</h4>
          <p>Select a conversation from the list to start messaging</p>
        </div>
        
        <div class="chat-header-detail" id="chatHeader" style="display: none;">
          <div class="current-contact">
            <div class="contact-avatar">
              <i class="fas fa-user-tie"></i>
            </div>
            <div class="contact-info">
              <div class="contact-name" id="currentContactName">Tutor Name</div>
              <div class="contact-subject" id="currentContactSubject">Subject</div>
            </div>
          </div>
          <div class="chat-actions">
            <button class="action-btn" onclick="scheduleSessionWithTutor()">
              <i class="fas fa-calendar-plus"></i> Schedule Session
            </button>
          </div>
        </div>
        
        <div class="messages-container" id="messagesContainer" style="display: none;">
          <!-- Messages will be loaded here -->
        </div>
        
        <div class="message-input-container" id="messageInputContainer" style="display: none;">
          <div class="message-input-wrapper">
            <textarea 
              class="message-input" 
              id="messageInput" 
              placeholder="Type your message..."
              rows="1"
            ></textarea>
            <button class="send-btn" id="sendMessageBtn">
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
          <div class="quick-actions">
            <button class="quick-action" onclick="insertQuickMessage('Can we schedule a session?')">
              Schedule Session
            </button>
            <button class="quick-action" onclick="insertQuickMessage('I need help with...')">
              Need Help
            </button>
            <button class="quick-action" onclick="insertQuickMessage('What are your available times?')">
              Availability
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="reviews" class="dashboard-section">
  <div class="section-header">
    <h3><i class="fas fa-star"></i> Session Reviews</h3>
    <p>Rate your completed tutoring sessions</p>
  </div>

<!-- Add the guidance section here -->
  <div class="review-guidance">
    <h4>Your Honest Feedback Matters</h4>
    <p>We encourage honest and constructive feedback to help tutors improve. 
       Tutors may respond professionally to address concerns.</p>
    <div class="protection-notice">
      <i class="fas fa-shield-alt"></i>
      <strong>Moderated for Professionalism:</strong> All responses are monitored for professionalism.
    </div>
  </div>
  
  <!-- Pending Reviews -->
  <div class="pending-reviews-section">
    <h4>Awaiting Your Review</h4>
    <div id="pendingReviewsContainer">
      <div class="empty-state">
        <i class="fas fa-check-circle"></i>
        <h4>All Caught Up!</h4>
        <p>No pending reviews. Your feedback helps tutors improve.</p>
      </div>
    </div>
  </div>

  <!-- Submitted Reviews -->
  <div class="submitted-reviews-section" style="margin-top: 30px;">
    <h4>Your Reviews</h4>
    <div id="submittedReviewsContainer">
      <div class="empty-state">
        <i class="fas fa-star"></i>
        <h4>No Reviews Yet</h4>
        <p>Your completed session reviews will appear here</p>
      </div>
    </div>
  </div>
</section>
    
<script>

// ====================================
// CRITICAL: Menu Toggle - Initialize First
// ====================================
document.addEventListener('DOMContentLoaded', function() {
  const menuToggle = document.getElementById('menuToggle');
  const sidebar = document.getElementById('sidebar');
  
  if (menuToggle && sidebar) {
    menuToggle.addEventListener('click', function(e) {
      e.preventDefault();
      sidebar.classList.toggle('active');
      console.log('Menu toggled');
    });
    console.log('Menu toggle initialized successfully');
  } else {
    console.error('Menu toggle or sidebar not found');
  }
});

// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
  const menuItems = document.querySelectorAll('.menu-item a');
  const sidebar = document.getElementById('sidebar');
  
  menuItems.forEach(item => {
    item.addEventListener('click', function() {
      // Check if we're on mobile (sidebar is visible)
      if (window.innerWidth <= 768 && sidebar.classList.contains('active')) {
        sidebar.classList.remove('active');
      }
    });
  });
});
  
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBjo5LY4EsFlX8j_8NbLUObooUsCqJM8KM",
  authDomain: "tk-scheduler.firebaseapp.com",
  projectId: "tk-scheduler",
  storageBucket: "tk-scheduler.appspot.com",
  messagingSenderId: "746606755052",
  appId: "1:746606755052:web:d7eae92976cb2f2fa9f9c9",
  measurementId: "G-Q5L607R3N7"
};

// Initialize Firebase with compat version
firebase.initializeApp(firebaseConfig);

// Initialize Firebase services
const auth = firebase.auth();
const db = firebase.firestore();

// Global variables
let currentUser = null;
let userData = null;
let sessionsDataLoaded = false;
let tutorsLoaded = false;
let bookingsLoaded = false;
let sessionsLoaded = false;
let schedulingLoaded = false; // ← ADD THIS
let inactivityTimer;

// Initialize the dashboard
function initDashboard() {
  // Wait for authentication to be ready
  if (!auth.currentUser) {
    console.log('Waiting for authentication...');
    setTimeout(initDashboard, 500); // Retry in 500ms
    return;
  }
  
  console.log('Initializing dashboard for user:', auth.currentUser.uid);
  
  // Initialize package store - ADD THIS LINE
  initPackageStore();
  
  // Set up navigation
document.querySelectorAll('.menu-item a').forEach(item => {
  item.addEventListener('click', function(e) {
    e.preventDefault();
    
    // Update active menu item
    document.querySelectorAll('.menu-item a').forEach(a => a.classList.remove('active'));
    this.classList.add('active');
    
    // Show the corresponding section
    const sectionId = this.getAttribute('data-section');
    document.querySelectorAll('.dashboard-section').forEach(section => {
      section.classList.remove('active');
    });
    document.getElementById(sectionId).classList.add('active');

    // Load specific data based on the section - ONLY if not already loaded
    if (sectionId === 'scheduling') {
      if (!schedulingLoaded) {
        loadTutorsForScheduling();
        schedulingLoaded = true;
      }
      // ADD THIS LINE HERE - it should run every time scheduling section is opened
      updateBookingButtonState();
    } else if (sectionId === 'tutors') {
      // Load both my tutors and available tutors when the tutors section is opened
      if (!tutorsLoaded) {
        loadMyTutors();
        loadAvailableTutors();
        tutorsLoaded = true;
      }
    } else if (sectionId === 'bookings') {
      if (!bookingsLoaded) {
        loadUserBookings();
        bookingsLoaded = true;
      }
    } else if (sectionId === 'sessions') {
      // Only load sessions history on first visit to the tab
      if (!sessionsLoaded) {
        loadUserSessionHistory();
        sessionsLoaded = true;
      }
    }
    // ADD PACKAGES SECTION HANDLING HERE IF NEEDED
    else if (sectionId === 'packages') {
      // Refresh package balance when packages section is opened
      loadPackageBalance();
    }
  // ADD CHAT SECTION HANDLING
else if (sectionId === 'chat') {
    // Initialize chat system only once
    if (!chatSystemInitialized) {
        initChatSystem();
    } else {
        // Just reload contacts if already initialized
        loadChatContacts();
    }
    
    // Ensure chat container is visible
    const chatContainer = document.getElementById('chatContainer');
    if (chatContainer) {
        chatContainer.style.display = 'block';
    }
}
  });
   });
  
  // Set up logout button
  document.getElementById('logoutBtn').addEventListener('click', function() {
    auth.signOut().then(() => {
      window.location.href = 'student-login.html';
    }).catch(error => {
      console.error('Logout error:', error);
    });
  });

  //......................................................................................
  //Profile Section starts here. All JS functionalities of the profile section starts here
 //.......................................................................................
  
  // Set up profile editing
  document.getElementById('editProfileBtn').addEventListener('click', function() {
    const form = document.getElementById('profileForm');
    if (form.style.display === 'none') {
      form.style.display = 'block';
      this.textContent = 'Cancel Editing';
    } else {
      form.style.display = 'none';
      this.textContent = 'Edit Profile';
    }
  });

  // Set up profile saving
document.getElementById('saveProfileBtn').addEventListener('click', saveProfile);
}  // <-- CLOSES initDashboard() function

// Initialize the dashboard when the page loads
document.addEventListener('DOMContentLoaded', initDashboard);

//.............................................................................
//Profile Section ends. All JS functionalities of the profile section ends here
//.............................................................................  

async function loadDashboardData() {
    await loadUserData(currentUser.uid);
    await loadMyTutors();
    await loadUserBookings();
    updateActiveTutorsCount();
}
  
// Load user data from Firestore
function loadUserData() {
  if (!currentUser) return;

  db.collection('students').doc(currentUser.uid).get()
    .then(doc => {
      if (doc.exists) {
        userData = doc.data();
        updateUIWithUserData();
      } else {
        console.error('No user data found');
      }
    })
    .catch(error => {
      console.error('Error loading user data:', error);
    });
}

// Update UI with user data
function updateUIWithUserData() {
  if (!userData) return;

  // Update user name and email in various places
  const userNameElements = document.querySelectorAll('#userName, #profileName');
  userNameElements.forEach(el => {
    el.textContent = userData.name || 'User';
  });

  const userEmailElements = document.querySelectorAll('#profileEmail, #email');
  userEmailElements.forEach(el => {
    el.value = userData.email || currentUser.email;
    if (el.tagName === 'SPAN') {
      el.textContent = userData.email || currentUser.email;
    }
  });

  // Update profile form fields
  document.getElementById('fullName').value = userData.name || '';
  document.getElementById('phone').value = userData.phone || '';
  document.getElementById('role').value = userData.role || 'Student';

  // Update profile status
  const profileStatus = document.getElementById('profileStatus');
  if (userData.emailVerified || currentUser.emailVerified) {
    profileStatus.textContent = 'Verified';
    profileStatus.className = 'status-badge status-verified';
  } else {
    profileStatus.textContent = 'Pending Verification';
    profileStatus.className = 'status-badge status-pending';
  }
}

// Save profile data to Firestore
function saveProfile() {
  if (!currentUser) return;

  const name = document.getElementById('fullName').value;
  const phone = document.getElementById('phone').value;

  // Update user data in Firestore
  db.collection('students').doc(currentUser.uid).update({
    name: name,
    phone: phone,
    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
  })
  .then(() => {
    alert('Profile updated successfully!');
    // Reload user data to update UI
    loadUserData();
    // Hide the form
    document.getElementById('profileForm').style.display = 'none';
    document.getElementById('editProfileBtn').textContent = 'Edit Profile';
  })
  .catch(error => {
    console.error('Error updating profile:', error);
    alert('Error updating profile. Please try again.');
  });
}

// Initialize the dashboard when the page loads
document.addEventListener('DOMContentLoaded', initDashboard);

//.............................................................................
//Profile Section ends. All JS functionalities of the profile section ends here
//.............................................................................  


//.......................................................................................
//Scheduling Section starts. All JS functionalities of the Scheduling section starts here
//....................................................................................... 

// Function to check if student has any package credits
async function checkStudentPackageBalance() {
  try {
    const studentDoc = await db.collection('students').doc(auth.currentUser.uid).get();
    
    if (!studentDoc.exists) {
      return { hasCredits: false, totalCredits: 0, message: 'Student not found' };
    }
    
    const studentData = studentDoc.data();
    const packageBalances = studentData.packageBalances || {};
    
    // Check ALL package types for available credits
    const availablePackages = ['taiwo', 'hourly', 'bronze', 'silver', 'gold'];
    let totalCredits = 0;
    let packageDetails = [];
    
    availablePackages.forEach(pkg => {
      const balance = packageBalances[pkg] || 0;
      if (balance > 0) {
        totalCredits += balance;
        packageDetails.push({ type: pkg, balance: balance });
      }
    });
    
    return {
      hasCredits: totalCredits > 0,
      totalCredits: totalCredits,
      packageDetails: packageDetails,
      message: totalCredits > 0 
        ? `You have ${totalCredits} session credit${totalCredits !== 1 ? 's' : ''} available` 
        : 'No package credits available'
    };
    
  } catch (error) {
    console.error('Error checking package balance:', error);
    return { hasCredits: false, totalCredits: 0, message: 'Error checking credits' };
  }
}

// Function to update booking button based on credit availability
async function updateBookingButtonState() {
  const submitButton = document.querySelector('#schedulingForm button[type="submit"]');
  if (!submitButton) return;
  
  const creditCheck = await checkStudentPackageBalance();
  
  if (!creditCheck.hasCredits) {
    submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i> No Credits Available';
    submitButton.style.backgroundColor = '#e53e3e';
    submitButton.title = 'Purchase package credits to book sessions';
  } else {
    submitButton.disabled = false;
    submitButton.innerHTML = '<i class="fas fa-calendar-check"></i> Schedule Session';
    submitButton.style.backgroundColor = '';
    submitButton.title = '';
  }
}

//Tutors are loaded for scheduling through the dropdown menu
function loadTutorsForScheduling() {
  console.log('🚨 loadTutorsForScheduling CALLED - Stack trace:', new Error().stack);
  const tutorSelect = document.getElementById('tutor');
  const tutorSpinner = document.getElementById('tutorSpinner');
  
  // Clear existing options except the first one
  while (tutorSelect.options.length > 1) {
    tutorSelect.remove(1);
  }
  
  tutorSpinner.style.display = 'block';

  // Tutors who are approved and available are queried
  db.collection('tutors')
    .where('available', '==', true)
    .where('approved', '==', true)
    .get()
    .then((querySnapshot) => {
      tutorSpinner.style.display = 'none';
      
if (querySnapshot.empty) {
  // Clear all except first option, then add no tutors message
  while (tutorSelect.options.length > 1) {
    tutorSelect.remove(1);
  }
  const noTutorsOption = document.createElement('option');
  noTutorsOption.value = "";
  noTutorsOption.textContent = "No available tutors found";
  tutorSelect.appendChild(noTutorsOption);
  return;
}
      querySnapshot.forEach((doc) => {
        const tutor = doc.data();
        const option = document.createElement('option');
        option.value = doc.id;
   
        // Extract tutor name and subjects based on your data structure
        const tutorName = tutor.personal?.fullName || 'Unknown Tutor';
        let subjectsText = 'No subjects listed';
        
        // Check for nested subjects structure
        if (tutor.subjects && tutor.subjects.subjects && tutor.subjects.subjects.length > 0) {
          subjectsText = tutor.subjects.subjects.join(', ');
        } else if (tutor.subjects && Array.isArray(tutor.subjects)) {
          // Fallback for different structure
          subjectsText = tutor.subjects.join(', ');
        }
        
        option.textContent = `${tutorName} - ${subjectsText}`;
        option.setAttribute('data-hourly-rate', tutor.professional?.hourlyRate || 30);
        tutorSelect.appendChild(option);
      });
    })
    .catch((error) => {
      tutorSpinner.style.display = 'none';
      console.error('Error loading tutors:', error);
      alert('Failed to load tutors. Please try again.');
    });
}

// Function to generate a unique meet ID (but not the actual link)
function generateMeetId() {
  return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Set up scheduling form for submission with credit validation
document.getElementById('schedulingForm').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  const submitButton = document.querySelector('#schedulingForm button[type="submit"]');
  const originalButtonText = submitButton.innerHTML;
  
  // Disable button and show spinner
  submitButton.disabled = true;
  submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking credits...';
  
  // First check if student has any package credits
  const creditCheck = await checkStudentPackageBalance();
  
  if (!creditCheck.hasCredits) {
    alert('❌ You need package credits to book a session. Please purchase a package first.');
    
    // Show package store section
    document.querySelectorAll('.menu-item a').forEach(a => a.classList.remove('active'));
    document.querySelectorAll('.dashboard-section').forEach(section => section.classList.remove('active'));
    
    document.querySelector('a[data-section="packages"]').classList.add('active');
    document.getElementById('packages').classList.add('active');
    
    // Re-enable button
    submitButton.disabled = false;
    submitButton.innerHTML = originalButtonText;
    return;
  }
  
 // Continue with booking if credits are available
  submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
  
  const tutorId = document.getElementById('tutor').value;
  const subject = document.getElementById('subject').value;
  const date = document.getElementById('date').value;
  const time = document.getElementById('time').value;
  const duration = document.getElementById('duration').value;
  const sessionType = document.getElementById('sessionType').value;
  const notes = document.getElementById('notes').value;
  
  if (!tutorId || !subject || !date || !time) {
    alert('Please fill in all required fields.');
    // Re-enable button
    submitButton.disabled = false;
    submitButton.innerHTML = originalButtonText;
    return;
  }

  // Combine date and time
  const dateTime = new Date(`${date}T${time}`);

  // Get tutor details for the booking
  db.collection('tutors').doc(tutorId).get()
    .then(async (tutorDoc) => {
      if (!tutorDoc.exists) {
        alert('Selected tutor not found.');
        // Re-enable button
        submitButton.disabled = false;
        submitButton.innerHTML = originalButtonText;
        return;
      }
      
      const tutor = tutorDoc.data();
      const studentId = auth.currentUser.uid;
      const studentName = userData?.name || 'Unknown Student';

      // Generate a unique slot ID
      const slotId = 'slot_' + Date.now();
      
      // Generate a unique meet ID (but NOT the actual Jitsi link)
      const meetId = generateMeetId();

      // Create booking in the bookedSessions collection
const bookingRef = await db.collection('bookedSessions').add({
  slotId: slotId,
  tutorId: tutorId,
  tutorName: tutor.personal?.fullName || 'Unknown Tutor',
  tutorEmail: tutor.personal?.email, // ← ADD THIS LINE
  studentId: studentId,
  studentName: studentName,
  studentEmail: userData?.email,
  subject: subject,
  date: dateTime,
  duration: duration,
  sessionType: sessionType,
  notes: notes,
  status: 'pending',
  bookedAt: new Date(),
  hourlyRate: parseFloat(tutor.professional?.hourlyRate) || 30,
  totalPrice: null,
  paymentStatus: 'pending_auto_deduction',
  meetCreated: false,
  meetId: meetId,
  meetLink: '',
  meetPlatform: '',
  confirmedAt: null,
  confirmedBy: null,
  studentCreditsAtBooking: creditCheck.totalCredits,
  
  // ✅ ADD REMINDER TRACKING FIELDS HERE
  reminder30minSent: false,
  reminder30minSentAt: null,
  reminderStartSent: false,
  reminderStartSentAt: null,
  lastReminderCheck: null
});

      // IMMEDIATELY deduct credit
try {
  const deductCredit = firebase.functions().httpsCallable('deductCreditOnSessionSubmission');
  const result = await deductCredit({ sessionId: bookingRef.id });
  
  if (!result.data.creditDeducted) {
    // If credit deduction fails, you might want to delete the session
    await db.collection('bookedSessions').doc(bookingRef.id).delete();
    throw new Error('No package credits available');
  }
  
} catch (error) {
  // Handle credit deduction failure
  console.error('Credit deduction failed:', error);
  alert('Failed to book session: ' + error.message);
  return;
}
      
      // CREATE CHAT ROOM FOR THIS SESSION
      try {
        const sessionData = {
          subject: subject,
          tutorName: tutor.personal?.fullName || 'Unknown Tutor',
          studentName: studentName
        };
        
        await createChatRoom(bookingRef.id, studentId, tutorId, sessionData);
        console.log('Chat room created for session:', bookingRef.id);
      } catch (chatError) {
        console.error('Failed to create chat room, but session was booked:', chatError);
        // Don't block the booking if chat creation fails
      }

      // ✅ ADD TUTOR NOTIFICATION CREATION RIGHT HERE
try {
  await db.collection('tutorNotifications').add({
    tutorId: tutorId,
    type: 'booking_request',
    title: 'New Booking Request! 📚',
    message: `${studentName} wants to book a ${subject} session`,
    priority: 'high',
    isRead: false,
    relatedSessionId: bookingRef.id,
    details: {
      studentName: studentName,
      studentId: studentId,
      subject: subject,
      date: dateTime.toLocaleDateString(),
      time: dateTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
      duration: duration,
      sessionType: sessionType,
      notes: notes || ''
    },
    createdAt: new Date()
  });
  console.log('Tutor notification created for session:', bookingRef.id);
} catch (notifyError) {
  console.error('Failed to create tutor notification, but session was booked:', notifyError);
  // Don't block the booking if notification creation fails
}

      alert('✅ Session request submitted successfully! It is now pending confirmation from the tutor. A chat room has been created for communication.');
      document.getElementById('schedulingForm').reset();
      document.getElementById('priceSummary').style.display = 'none';
      document.getElementById('subject').innerHTML = '<option value="">Select a tutor first</option>';
      document.getElementById('subject').disabled = true;
      
      // Immediately add the new booking to the UI
      addBookingToUI(bookingRef.id, {
        slotId: slotId,
        tutorId: tutorId,
        tutorName: tutor.personal?.fullName || 'Unknown Tutor',
        studentId: studentId,
        studentName: studentName,
        subject: subject,
        date: firebase.firestore.Timestamp.fromDate(dateTime),
        duration: duration,
        sessionType: sessionType,
        notes: notes,
        status: 'pending',
        bookedAt: new Date(),
        hourlyRate: parseFloat(tutor.professional?.hourlyRate) || 30,
        totalPrice: (parseFloat(tutor.professional?.hourlyRate) || 30) * parseFloat(duration),
        meetLink: '',
        meetCreated: false,
        meetId: meetId,
        meetPlatform: '',
        paymentStatus: 'pending_auto_deduction',

        // ✅ ADD THESE HERE TOO FOR UI CONSISTENCY
  reminder30minSent: false,
  reminder30minSentAt: null,
  reminderStartSent: false,
  reminderStartSentAt: null
});
      
      // Re-enable button and restore original text
      submitButton.disabled = false;
      submitButton.innerHTML = originalButtonText;
      
      // Update button state after booking
      updateBookingButtonState();
    })
    .catch((error) => {
      console.error('Error creating booking:', error);
      alert('Failed to submit session request. Please try again.');
      // Re-enable button and restore original text
      submitButton.disabled = false;
      submitButton.innerHTML = originalButtonText;
    });
});

// Set up tutor selection change event
document.getElementById('tutor').addEventListener('change', function() {
  const tutorId = this.value;
  const subjectSelect = document.getElementById('subject');
  const priceSummary = document.getElementById('priceSummary');
  const hourlyRateSpan = document.getElementById('hourlyRate');
  const durationDisplay = document.getElementById('durationDisplay');
  const totalPriceSpan = document.getElementById('totalPrice');
  
  if (!tutorId) {
    subjectSelect.innerHTML = '<option value="">Select a tutor first</option>';
    subjectSelect.disabled = true;
    priceSummary.style.display = 'none';
    return;
  }
  
  // Get tutor data to populate subjects and hourly rate
  db.collection('tutors').doc(tutorId).get()
    .then((doc) => {
      if (doc.exists) {
        const tutor = doc.data();
        
        // Populate subjects (existing code remains)
        subjectSelect.innerHTML = '';
        let subjects = [];
        
        if (tutor.subjects && tutor.subjects.subjects && tutor.subjects.subjects.length > 0) {
          subjects = tutor.subjects.subjects;
        } else if (tutor.subjects && Array.isArray(tutor.subjects)) {
          subjects = tutor.subjects;
        }
        
        if (subjects.length > 0) {
          subjects.forEach(subject => {
            const option = document.createElement('option');
            option.value = subject;
            option.textContent = subject;
            subjectSelect.appendChild(option);
          });
          subjectSelect.disabled = false;
        } else {
          subjectSelect.innerHTML = '<option value="">No subjects available</option>';
          subjectSelect.disabled = true;
        }
        
        // CHECK PACKAGE BALANCE - UPDATED TO CHECK ALL PACKAGES
        db.collection('students').doc(auth.currentUser.uid).get()
          .then((studentDoc) => {
            let packageMessage = '';
            let showPackagePricing = false;
            let totalCredits = 0;
            
            if (studentDoc.exists) {
              const studentData = studentDoc.data();
              const packageBalances = studentData.packageBalances || {};
              
              // Check ALL package types
              const availablePackages = ['taiwo', 'hourly', 'bronze', 'silver', 'gold'];
              availablePackages.forEach(pkg => {
                totalCredits += packageBalances[pkg] || 0;
              });
              
              if (totalCredits > 0) {
                packageMessage = `Package Credits Available: ${totalCredits} session${totalCredits !== 1 ? 's' : ''}`;
                showPackagePricing = true;
              }
            }
            
            // Show price summary
            const hourlyRate = parseFloat(tutor.professional?.hourlyRate) || 30;
            const duration = parseFloat(document.getElementById('duration').value) || 1.5;
            
            if (showPackagePricing) {
              // Student has package credits - show package pricing
              hourlyRateSpan.textContent = '0 (Package Credit)';
              durationDisplay.textContent = duration;
              totalPriceSpan.textContent = '0.00';
              priceSummary.innerHTML = `
                <h4>Package Pricing</h4>
                <p style="color: #48bb78; font-weight: bold;">${packageMessage}</p>
                <p>Hourly Rate: $<span id="hourlyRate">0 (Package Credit)</span></p>
                <p>Duration: <span id="durationDisplay">${duration}</span> hours</p>
                <p><strong>Total: $<span id="totalPrice">0.00</span></strong></p>
                <p style="font-size: 0.9em; color: #666;">1 package credit will be automatically deducted 24 hours before session</p>
              `;
            } else {
              // No package credits - show regular pricing with warning
              const totalPrice = hourlyRate * duration;
              hourlyRateSpan.textContent = hourlyRate;
              durationDisplay.textContent = duration;
              totalPriceSpan.textContent = totalPrice.toFixed(2);
              priceSummary.innerHTML = `
                <h4>Price Summary</h4>
                <p style="color: #e53e3e; font-weight: bold;">⚠️ No package credits available</p>
                <p>Hourly Rate: $<span id="hourlyRate">${hourlyRate}</span></p>
                <p>Duration: <span id="durationDisplay">${duration}</span> hours</p>
                <p><strong>Total: $<span id="totalPrice">${totalPrice.toFixed(2)}</span></strong></p>
                <p style="font-size: 0.9em; color: #e53e3e;">You need package credits to book sessions</p>
              `;
            }
            
            priceSummary.style.display = 'block';
            
            // Update booking button state based on credits
            updateBookingButtonState();
          })
          .catch((error) => {
            console.error('Error checking package balance:', error);
            // Fallback to regular pricing
            const hourlyRate = parseFloat(tutor.professional?.hourlyRate) || 30;
            const duration = parseFloat(document.getElementById('duration').value) || 1.5;
            const totalPrice = hourlyRate * duration;
            
            hourlyRateSpan.textContent = hourlyRate;
            durationDisplay.textContent = duration;
            totalPriceSpan.textContent = totalPrice.toFixed(2);
            priceSummary.innerHTML = `
              <h4>Price Summary</h4>
              <p>Hourly Rate: $<span id="hourlyRate">${hourlyRate}</span></p>
              <p>Duration: <span id="durationDisplay">${duration}</span> hours</p>
              <p><strong>Total: $<span id="totalPrice">${totalPrice.toFixed(2)}</span></strong></p>
            `;
            priceSummary.style.display = 'block';
          });
      }
    })
    .catch((error) => {
      console.error('Error loading tutor details:', error);
      subjectSelect.innerHTML = '<option value="">Error loading subjects</option>';
      subjectSelect.disabled = true;
      priceSummary.style.display = 'none';
    });
});
  
// Set up duration change event to update price
document.getElementById('duration').addEventListener('change', function() {
  const tutorSelect = document.getElementById('tutor');
  const tutorId = tutorSelect.value;
  
  if (!tutorId) return;
  
  // Get tutor hourly rate
  db.collection('tutors').doc(tutorId).get()
    .then((doc) => {
      if (doc.exists) {
        const tutor = doc.data();
        const hourlyRate = parseFloat(tutor.professional?.hourlyRate) || 30;
        const duration = parseFloat(this.value) || 1.5;
        const totalPrice = hourlyRate * duration;
        
        document.getElementById('hourlyRate').textContent = hourlyRate;
        document.getElementById('durationDisplay').textContent = duration;
        document.getElementById('totalPrice').textContent = totalPrice.toFixed(2);
      }
    })
    .catch((error) => {
      console.error('Error loading tutor details:', error);
    });
});

// Add new booking to UI immediately
function addBookingToUI(bookingId, bookingData) {
  const container = document.getElementById('bookingsContainer');
  
  // Format date and time
  const date = bookingData.date.toDate();
  const formattedDate = date.toLocaleDateString();
  const formattedTime = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  
  // Create booking card HTML
  const bookingCard = `
    <div class="session-card" id="booking-${bookingId}">
      <div class="session-header">
        <div class="session-title">${bookingData.subject || 'No subject'}</div>
        <div class="session-date">${formattedDate} at ${formattedTime}</div>
      </div>
      <div class="session-details">
        <div class="session-detail">
          <i class="fas fa-user-tie"></i>
          <span>Tutor: ${bookingData.tutorName || 'Unknown'}</span>
        </div>
        <div class="session-detail">
          <i class="fas fa-clock"></i>
          <span>Duration: ${bookingData.duration || '1'} hours</span>
        </div>
        <div class="session-detail">
          <i class="fas fa-video"></i>
          <span>Type: ${bookingData.sessionType === 'in-person' ? 'In-Person' : 'Online'}</span>
        </div>
        <div class="session-detail">
          <i class="fas fa-hourglass-half"></i>
          <span>Status: <span class="status-badge status-pending">Pending</span></span>
        </div>
      </div>
      <div class="session-actions">
        <button class="btn-outline" onclick="cancelBooking('${bookingId}')">Cancel Request</button>
      </div>
    </div>
  `;
  
  // If container has empty state message, replace it
  if (container.innerHTML.includes('no upcoming bookings') || container.innerHTML.includes('<p>Loading')) {
    container.innerHTML = bookingCard;
  } else {
    // Prepend the new booking to the top
    container.innerHTML = bookingCard + container.innerHTML;
  }
  
  // Update upcoming sessions count
  const currentCount = parseInt(document.getElementById('upcomingSessionsCount').textContent);
  document.getElementById('upcomingSessionsCount').textContent = currentCount + 1;
}

// Add this function to your existing JavaScript
async function createChatRoom(sessionId, studentId, tutorId, sessionData) {
    // Generate consistent chat ID (same for all sessions between this student and tutor)
    const chatId = [studentId, tutorId].sort().join('_');
    
    try {
        // Get user names
        const [studentDoc, tutorDoc] = await Promise.all([
            db.collection('students').doc(studentId).get(),
            db.collection('tutors').doc(tutorId).get()
        ]);
        
        const studentName = studentDoc.data()?.name || studentDoc.data()?.fullName || 'Student';
        const tutorName = tutorDoc.data()?.personal?.fullName || tutorDoc.data()?.fullName || 'Tutor';
        
        // Check if chat already exists
        const existingChat = await db.collection('chats').doc(chatId).get();
        
        if (existingChat.exists) {
            // Chat exists - just update it with new session info if needed
            console.log('Using existing chat room:', chatId);
            
            // Update the chat with current session info
            await db.collection('chats').doc(chatId).update({
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                // Keep existing sessionId or update to latest? 
                // You might want to track multiple sessions or keep the latest
                latestSessionId: sessionId,
                subject: sessionData.subject || existingChat.data().subject || 'General Tutoring'
            });
            
            return chatId;
        } else {
            // Create new chat room
            await db.collection('chats').doc(chatId).set({
                participants: [studentId, tutorId],
                participantNames: {
                    [studentId]: studentName,
                    [tutorId]: tutorName
                },
                sessionId: sessionId, // Store the first session ID
                latestSessionId: sessionId, // Track latest session
                subject: sessionData.subject || 'General Tutoring',
                status: 'active',
                lastMessage: '',
                lastMessageAt: null,
                unreadCounts: { 
                    [studentId]: 0, 
                    [tutorId]: 0 
                },
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            console.log('Created new chat room:', chatId);
            return chatId;
        }
        
    } catch (error) {
        console.error('Error creating chat room:', error);
        throw error;
    }
}


  
//..........................................................................................
//Scheduling Section ends here. All JS functionalities of the scheduling section ends here
//...........................................................................................//..........................................................................................
//My Tutors Section starts here. All JS functionalities of the My Tutors section starts here
//...........................................................................................

  // Load available tutors
function loadAvailableTutors() {
  const container = document.getElementById('availableTutorsContainer');
  if (!container) return;
  
  container.innerHTML = '<div class="spinner" id="tutorsSpinner"></div>';
  
  // Query tutors who are available and approved
  db.collection('tutors')
    .where('available', '==', true)
    .where('approved', '==', true)
    .get()
    .then((querySnapshot) => {
      if (!container) return;
      container.innerHTML = '';
      
      if (querySnapshot.empty) {
        container.innerHTML = '<div class="empty-state"><i class="fas fa-user-slash"></i><h3>No Available Tutors</h3><p>There are no tutors available at the moment. Please check back later.</p></div>';
        return;
      }
      
      querySnapshot.forEach((doc) => {
        const tutor = doc.data();
        const tutorCard = document.createElement('div');
        tutorCard.className = 'tutor-card';
        tutorCard.innerHTML = `
          <div class="tutor-header">
            <div class="tutor-avatar">
              <img src="${tutor.photoURL || 'https://via.placeholder.com/70'}" alt="${tutor.personal?.fullName || 'Tutor'}">
            </div>
            <div class="tutor-name">${tutor.personal?.fullName || 'Unknown Tutor'}</div>
            <div class="tutor-subject">${tutor.subjects?.subjects ? tutor.subjects.subjects.join(', ') : 'No subjects listed'}</div>
          </div>
          <div class="tutor-details">
            <p><i class="fas fa-graduation-cap"></i> ${tutor.professional?.qualifications || 'No qualifications listed'}</p>
            <p><i class="fas fa-star"></i> Rating: ${tutor.rating || 'No rating'} (${tutor.reviewCount || 0} reviews)</p>
            <p><i class="fas fa-dollar-sign"></i> $${tutor.professional?.hourlyRate || 'N/A'}/hour</p>
            <p><i class="fas fa-clock"></i> Response time: ${tutor.responseTime || 'Unknown'}</p>
            <button class="btn-primary" onclick="bookTutor('${doc.id}')">Book Session</button>
            <button class="btn-outline" onclick="startNewChat('${doc.id}')">
              <i class="fas fa-comments"></i> Message Tutor
            </button>
          </div>
        `;
        container.appendChild(tutorCard);
      });
    })
    .catch((error) => {
      console.error('Error loading available tutors:', error);
      if (container) {
        container.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-circle"></i><h3>Error Loading Tutors</h3><p>Failed to load available tutors. Please try again later.</p></div>';
      }
    });
}
  
// Load my tutors (tutors the student has previously booked with)
function loadMyTutors() {
  const container = document.getElementById('myTutorsContainer');
  if (!container) return;
  
  container.innerHTML = '<div class="spinner"></div>';
  
  // Get the current user ID
  const userId = auth.currentUser?.uid;
  if (!userId) {
    container.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-circle"></i><h3>Authentication Error</h3><p>Please log in to view your tutors.</p></div>';
    return;
  }
  
  // Query sessions where this student is involved and status is confirmed
  db.collection('bookedSessions')
    .where('studentId', '==', userId)
    .where('status', 'in', ['confirmed', 'pending']) // Include both confirmed and pending
    .where('date', '>=', new Date()) // Only future sessions or recent ones
    .orderBy('date', 'asc')
    .get()
    .then((querySnapshot) => {
      if (!container) return;
      container.innerHTML = '';
      
      if (querySnapshot.empty) {
        container.innerHTML = '<div class="empty-state"><i class="fas fa-user-slash"></i><h3>No Active Tutors</h3><p>You don\'t have any upcoming sessions with tutors. Book a session to get started!</p></div>';
        return;
      }
      
      // Collect unique tutor IDs from confirmed/pending sessions
      const tutorIds = [];
      querySnapshot.forEach((doc) => {
        const session = doc.data();
        if (session.tutorId && !tutorIds.includes(session.tutorId)) {
          tutorIds.push(session.tutorId);
        }
      });
      
      if (tutorIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><i class="fas fa-user-slash"></i><h3>No Active Tutors</h3><p>You don\'t have any upcoming sessions with tutors. Book a session to get started!</p></div>';
        return;
      }
      
      // Get tutor details for each tutor ID
      const tutorPromises = tutorIds.map(tutorId => 
        db.collection('tutors').doc(tutorId).get()
      );
      
      Promise.all(tutorPromises)
        .then((tutorSnapshots) => {
          if (!container) return;
          
          tutorSnapshots.forEach((tutorDoc) => {
            if (tutorDoc.exists) {
              const tutor = tutorDoc.data();
              const tutorCard = document.createElement('div');
              tutorCard.className = 'tutor-card';
              tutorCard.innerHTML = `
                <div class="tutor-header">
                  <div class="tutor-avatar">
                    <img src="${tutor.photoURL || 'https://via.placeholder.com/70'}" alt="${tutor.personal?.fullName || 'Tutor'}">
                  </div>
                  <div class="tutor-name">${tutor.personal?.fullName || 'Unknown Tutor'}</div>
                  <div class="tutor-subject">${tutor.subjects?.subjects ? tutor.subjects.subjects.join(', ') : 'No subjects listed'}</div>
                </div>
                <div class="tutor-details">
                  <p><i class="fas fa-graduation-cap"></i> ${tutor.professional?.qualifications || 'No qualifications listed'}</p>
                  <p><i class="fas fa-star"></i> Rating: ${tutor.rating || 'No rating'} (${tutor.reviewCount || 0} reviews)</p>
                  <p><i class="fas fa-clock"></i> Next session: Confirmed</p>
                  <button class="btn-primary" onclick="bookTutor('${tutorDoc.id}')">Book Again</button>
                </div>
              `;
              container.appendChild(tutorCard);
            }
          });
        })
        .catch((error) => {
          console.error('Error loading tutor details:', error);
          if (container) {
            container.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-circle"></i><h3>Error Loading Tutors</h3><p>Failed to load your tutors. Please try again later.</p></div>';
          }
        });
    })
    .catch((error) => {
      console.error('Error loading sessions:', error);
      if (container) {
        container.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-circle"></i><h3>Error Loading Tutors</h3><p>Failed to load your tutors. Please try again later.</p></div>';
      }
    });
}

// Update active tutors count
function updateActiveTutorsCount() {
  const userId = auth.currentUser?.uid;
  if (!userId) return;

  db.collection('bookedSessions')
    .where('studentId', '==', userId)
    .where('status', 'in', ['confirmed', 'pending'])
    .where('date', '>=', new Date())
    .get()
    .then((querySnapshot) => {
      // Get unique tutor IDs
      const tutorIds = new Set();
      querySnapshot.forEach(doc => {
        const session = doc.data();
        if (session.tutorId) {
          tutorIds.add(session.tutorId);
        }
      });
      
      document.getElementById('tutorsCount').textContent = tutorIds.size;
    })
    .catch(error => {
      console.error('Error counting active tutors:', error);
    });
}
  
// Book a tutor
function bookTutor(tutorId) {
  // Switch to scheduling tab and pre-select the tutor
  const schedulingLink = document.querySelector('a[data-section="scheduling"]');
  const schedulingSection = document.getElementById('scheduling');
  
  if (schedulingLink && schedulingSection) {
    document.querySelectorAll('.menu-item a').forEach(a => a.classList.remove('active'));
    document.querySelectorAll('.dashboard-section.active').forEach(section => section.classList.remove('active'));
    
    schedulingLink.classList.add('active');
    schedulingSection.classList.add('active');
    
    // Wait for the scheduling section to be visible, then select the tutor
    setTimeout(() => {
      const tutorSelect = document.getElementById('tutor');
      if (tutorSelect) {
        tutorSelect.value = tutorId;
        
        // Trigger change event to load subjects
        const event = new Event('change');
        tutorSelect.dispatchEvent(event);
      }
    }, 100);
  }
}

// Set up tabs in the tutors section
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', function() {
    // Update active tab
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    this.classList.add('active');
    
    // Show the corresponding tab content
    const tabId = this.getAttribute('data-tab');
    const tabContent = document.getElementById(`${tabId}-tab`);
    const searchContainer = document.getElementById('tutorSearchContainer');
    
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
    });
    
    if (tabContent) {
      tabContent.classList.add('active');
    }
    
    // Show search only for available tutors
    if (searchContainer) {
      searchContainer.style.display = tabId === 'available-tutors' ? 'block' : 'none';
    }
  });
});

//.........................................................................................
//My Tutors Section ends here. All JS functionalities of the My Tutors section ends here
//..........................................................................................

//...........................................................................................
//...........................................................................................
// My Bookings Section starts here. All JS functionalities of My Bookings section starts here
//...........................................................................................

// Helper function to get CSS class for status badges
function getStatusClass(status) {
    switch(status) {
        case 'confirmed':
        case 'completed':
            return 'status-verified';
        case 'pending':
            return 'status-pending';
        case 'cancelled':
            return 'status-cancelled';
        case 'reschedule_requested':
            return 'status-reschedule-requested';
        default:
            return 'status-pending';
    }
}

// Count the number of upcoming sessions and show on the display dashboard
function updateUpcomingSessionsCount(count) {
    const countElement = document.getElementById('upcomingSessionsCount');
    if (countElement) {
        countElement.textContent = count;
    }
}

// Cancel a booking function
function cancelBooking(bookingId) {
    // First confirm cancellation
    if (!confirm('Are you sure you want to cancel this booking?')) {
        return;
    }

    // Show loading state on the button
    const cancelBtn = document.querySelector(`[data-session-id="${bookingId}"][data-action="cancel"]`);
    if (cancelBtn) {
        const originalText = cancelBtn.innerHTML;
        cancelBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Cancelling...';
        cancelBtn.disabled = true;
    }

    // Get session details first to check 24-hour policy
    let sessionData; // Store session data for later use
    
    db.collection('bookedSessions').doc(bookingId).get()
        .then((doc) => {
            if (!doc.exists) {
                alert('Booking not found.');
                resetCancelButton(cancelBtn);
                throw new Error('Booking not found'); // Break the chain
            }

            const session = doc.data();
            sessionData = session; // Store for later use
            
            const sessionTime = session.date.toDate();
            const now = new Date();
            const twentyFourHoursBefore = new Date(sessionTime.getTime() - 24 * 60 * 60 * 1000);
            
            const isWithin24Hours = now >= twentyFourHoursBefore;
            
            // Show appropriate warning based on timing
            let confirmMessage;
            if (isWithin24Hours) {
                confirmMessage = 
                    '⚠️ CANCELLATION WITHIN 24 HOURS\n\n' +
                    'Cancelling this session will result in losing your session credit.\n\n' +
                    'Credit Policy:\n' +
                    '• Within 24 hours: Credit is NOT refunded\n' +
                    '• Outside 24 hours: Credit is refunded\n\n' +
                    'Do you still want to cancel this session?';
            } else {
                confirmMessage = 
                    'Are you sure you want to cancel this booking?\n\n' +
                    '✅ Your session credit will be refunded to your account.';
            }

            // Double confirmation with policy information
            if (!confirm(confirmMessage)) {
                resetCancelButton(cancelBtn);
                throw new Error('User cancelled confirmation'); // Break the chain
            }

            // Proceed with cancellation via Firebase function
            const cancelSession = firebase.functions().httpsCallable('cancelSession');
            return cancelSession({ sessionId: bookingId });
        })
        .then((result) => {
            if (!result) {
                resetCancelButton(cancelBtn);
                return; // User cancelled confirmation
            }

            // Create tutor notification for cancellation
            return db.collection('tutorNotifications').add({
                tutorId: sessionData.tutorId,
                type: 'session_cancelled',
                title: 'Session Cancelled by Student',
                message: `${sessionData.studentName} cancelled your ${sessionData.subject} session`,
                details: {
                    studentName: sessionData.studentName,
                    studentId: sessionData.studentId,
                    sessionId: bookingId,
                    subject: sessionData.subject,
                    date: sessionData.date.toDate().toLocaleDateString(),
                    time: sessionData.date.toDate().toLocaleTimeString(),
                    duration: sessionData.duration,
                    meetLink: sessionData.meetLink || '',
                    meetPlatform: sessionData.meetPlatform || ''
                },
                relatedSessionId: bookingId,
                isRead: false,
                priority: 'high',
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => result); // Return the original result along with notification
        })
        .then((result) => {
            if (!result) return; // User cancelled confirmation

            // Success handling
            alert(result.data.message);
            
            // Refresh UI components
            loadUserBookings();
            loadPackageBalance(); // Refresh credit balance
            
            // Show success message with credit info
            if (result.data.creditRefunded) {
                showToast('Session cancelled successfully. Credit has been refunded!', 'success');
            } else {
                showToast('Session cancelled. Credit was not refunded due to 24-hour policy.', 'warning');
            }
        })
        .catch((error) => {
            console.error('Cancellation error:', error);
            if (error.message !== 'User cancelled confirmation') {
                handleCancellationError(error, bookingId);
            }
        })
        .finally(() => {
            resetCancelButton(cancelBtn);
        });
}  
// Helper function to reset cancel button
function resetCancelButton(button) {
    if (button) {
        button.disabled = false;
        button.innerHTML = '<i class="fas fa-times"></i> Cancel';
    }
}

// Enhanced error handling function
function handleCancellationError(error, sessionId) {
    console.error('Cancellation error:', error);
    
    // Handle specific 24-hour policy error
    if (error.code === 'failed-precondition' || 
        error.message?.includes('24 hours') || 
        error.details?.includes('24 hours')) {
        
        alert(
            '❌ CANCELLATION NOT POSSIBLE\n\n' +
            'You cannot cancel this session because it starts within 24 hours.\n\n' +
            'Credit Policy:\n' +
            '• Cancellations within 24 hours of session time result in credit loss\n' +
            '• Credits are only refunded for cancellations made more than 24 hours in advance\n\n' +
            'Please contact support if you have exceptional circumstances.'
        );
    } 
    // Handle other common errors
    else if (error.code === 'permission-denied') {
        alert('❌ Permission denied. You cannot cancel this session.');
    } else if (error.code === 'not-found') {
        alert('❌ Session not found. It may have already been cancelled.');
    } else {
        alert('❌ Failed to cancel session: ' + (error.message || 'Please try again.'));
    }
}
  
// Join session function with Jitsi Meet
function joinSession(sessionId) {
    console.log('Attempting to join session:', sessionId);

    db.collection('bookedSessions').doc(sessionId).get()
        .then((doc) => {
            if (!doc.exists) {
                alert('Session not found.');
                return;
            }

            const session = doc.data();
            const now = new Date();
            const sessionTime = session.date && typeof session.date.toDate === 'function' ? session.date.toDate() : new Date(session.date);
            
            // Calculate session end time (start time + duration)
            const sessionEndTime = new Date(sessionTime);
            const durationHours = parseFloat(session.duration) || 1.5;
            sessionEndTime.setHours(sessionEndTime.getHours() + durationHours);

            // Check if session is confirmed
            if (session.status !== 'confirmed') {
                alert('This session has not been confirmed yet. Please wait for tutor confirmation.');
                return;
            }

            // Check if tutor has created a meeting link
            if (!session.meetLink) {
                alert('Meeting link not available yet. Please wait for the tutor to create the meeting.');
                return;
            }

            // Allow joining 15 minutes before and up to session end time
            const fifteenMinutesBefore = new Date(sessionTime);
            fifteenMinutesBefore.setMinutes(fifteenMinutesBefore.getMinutes() - 15);

            if (now < fifteenMinutesBefore) {
                const minutesUntilSession = (sessionTime.getTime() - now.getTime()) / (1000 * 60);
                alert(`Session starts in ${Math.ceil(minutesUntilSession)} minutes. You can join 15 minutes before the session.`);
                return;
            } else if (now > sessionEndTime) {
                alert('This session has already ended. Joining is no longer available.');
                return;
            }

            // Validate URL before opening
            try {
                const url = new URL(session.meetLink);
                if (url.protocol === 'https:') {
                    // Record join attempt for analytics
                    recordJoinAttempt(sessionId, auth.currentUser.uid);
                    
                    // Open the meeting link in a new tab
                    window.open(session.meetLink, '_blank', 'noopener,noreferrer');
                } else {
                    alert('Invalid meeting link.');
                }
            } catch (e) {
                alert('Invalid meeting link. Please contact the tutor.');
            }
        })
        .catch(err => {
            console.error('Error joining session:', err);
            alert('Failed to join session. Please try again.');
        });
}

// Record join attempt in Firestore
function recordJoinAttempt(sessionId, userId) {
    const joinData = {
        userId: userId,
        joinedAt: new Date(),
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        role: 'student'
    };
    
    db.collection('bookedSessions').doc(sessionId).collection('joinAttempts').add(joinData)
        .then(() => {
            console.log('Join attempt recorded for session:', sessionId);
        })
        .catch((error) => {
            console.error('Error recording join attempt:', error);
        });
}
            
// Function for reschedule response - UPDATED for your actual data structure
function respondToReschedule(bookingId, response) {
    if (!confirm(`Are you sure you want to ${response} this reschedule request?`)) {
        return;
    }

    // Get the current booking to access the proposed new date
    db.collection('bookedSessions').doc(bookingId).get()
        .then((doc) => {
            if (!doc.exists) {
                alert('Booking not found.');
                return;
            }

            const booking = doc.data();
            
            // Verify there's a reschedule request
            if (!booking.rescheduleRequested || !booking.proposedNewDate) {
                alert('No reschedule request found for this booking.');
                return;
            }

            let updateData;
            let notificationData;

            if (response === 'accept') {
                updateData = {
                    date: booking.proposedNewDate,
                    status: 'confirmed',
                    rescheduleStatus: 'accepted',
                    rescheduleRespondedAt: new Date(),
                    rescheduleRespondedBy: 'student',
                    previousDate: booking.date,
                    rescheduleRequested: false,
                    proposedNewDate: null,
                    rescheduleReason: null
                };

                notificationData = {
                    tutorId: booking.tutorId,
                    type: 'reschedule_accepted',
                    title: 'Reschedule Accepted by Student',
                    message: `${booking.studentName} accepted your reschedule request for ${booking.subject}`,
                    details: {
                        studentName: booking.studentName,
                        studentId: booking.studentId,
                        sessionId: bookingId,
                        subject: booking.subject,
                        date: booking.proposedNewDate.toDate().toLocaleDateString(),
                        time: booking.proposedNewDate.toDate().toLocaleTimeString(),
                        duration: booking.duration,
                        meetLink: booking.meetLink || '',
                        meetPlatform: booking.meetPlatform || '',
                        originalDate: booking.date.toDate().toLocaleDateString(),
                        originalTime: booking.date.toDate().toLocaleTimeString()
                    },
                    relatedSessionId: bookingId,
                    isRead: false,
                    priority: 'medium',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

            } else {
                updateData = {
                    status: 'confirmed',
                    rescheduleStatus: 'declined',
                    rescheduleRespondedAt: new Date(),
                    rescheduleRespondedBy: 'student',
                    rescheduleRequested: false,
                    proposedNewDate: null,
                    rescheduleReason: null
                };

                notificationData = {
                    tutorId: booking.tutorId,
                    type: 'reschedule_rejected',
                    title: 'Reschedule Rejected by Student',
                    message: `${booking.studentName} rejected your reschedule request for ${booking.subject}`,
                    details: {
                        studentName: booking.studentName,
                        studentId: booking.studentId,
                        sessionId: bookingId,
                        subject: booking.subject,
                        date: booking.date.toDate().toLocaleDateString(),
                        time: booking.date.toDate().toLocaleTimeString(),
                        duration: booking.duration,
                        meetLink: booking.meetLink || '',
                        meetPlatform: booking.meetPlatform || '',
                        originalDate: booking.date.toDate().toLocaleDateString(),
                        originalTime: booking.date.toDate().toLocaleTimeString()
                    },
                    relatedSessionId: bookingId,
                    isRead: false,
                    priority: 'medium',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
            }

            // Update the booking AND create notification in parallel
            return Promise.all([
                db.collection('bookedSessions').doc(bookingId).update(updateData),
                db.collection('tutorNotifications').add(notificationData)
            ]);
        })
        .then(() => {
            alert(`Reschedule request ${response}ed successfully.`);
            // Reload the bookings to reflect the changes
            loadUserBookings();
        })
        .catch((error) => {
            console.error('Error responding to reschedule request:', error);
            alert('Failed to respond to reschedule request. Please try again.');
        });
}
          
// Global event listener for bookings container
let bookingsContainerListener = null;

// Update the loadBookingsDisplay function to show appropriate messaging
function loadBookingsDisplay(bookings) {
    const container = document.getElementById('bookingsContainer');
    if (!container) return;
    
    if (bookings.length === 0) {
        container.innerHTML = '<div class="empty-state"><i class="fas fa-calendar-times"></i><h3>No Upcoming Bookings</h3><p>You have no upcoming sessions scheduled.</p></div>';
        return;
    }
    
    let html = '';
    const now = new Date();
    
    bookings.forEach(booking => {
        // Handle date conversion
        let date;
        if (booking.date && typeof booking.date.toDate === 'function') {
            date = booking.date.toDate();
        } else {
            date = new Date(booking.date);
        }
        
        const formattedDate = date.toLocaleDateString();
        const formattedTime = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        // Calculate if session can be joined (15 minutes before to session end time)
        const sessionEndTime = new Date(date.getTime() + (booking.duration * 60 * 60 * 1000));
        const canJoin = now >= new Date(date.getTime() - 15 * 60 * 1000) && 
                       now <= sessionEndTime;
        
        // Check if meeting link is available
        const meetLinkAvailable = booking.meetLink && booking.status === 'confirmed' && booking.meetCreated;
        
        // Sanitize all user inputs to prevent XSS
        const subject = booking.subject || 'No subject';
        const sanitizedSubject = subject.replace(/[<>"'&]/g, '');
        const tutorName = (booking.tutorName || 'Unknown').replace(/[<>"'&]/g, '');
        const duration = (booking.duration || '1').replace(/[<>"'&]/g, '');
        const sessionType = (booking.sessionType === 'in-person' ? 'In-Person' : 'Online').replace(/[<>"'&]/g, '');
        const status = (booking.status || 'pending').replace(/[<>"'&]/g, '');
        const sanitizedId = booking.id.replace(/[^a-zA-Z0-9_-]/g, '');
        
        // Check if there's a pending reschedule with proposed new date
        let rescheduleInfo = '';
        if (booking.hasPendingReschedule && booking.rescheduleRequest) {
            let newDate;
            if (booking.rescheduleRequest.requestedDate && typeof booking.rescheduleRequest.requestedDate.toDate === 'function') {
                newDate = booking.rescheduleRequest.requestedDate.toDate();
            } else {
                newDate = new Date(booking.rescheduleRequest.requestedDate);
            }
            
            const newFormattedDate = newDate.toLocaleDateString();
            const newFormattedTime = newDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const reason = (booking.rescheduleRequest.reason || 'No reason provided').replace(/[<>"'&]/g, '');
            const requestedBy = (booking.rescheduleRequest.requestedBy || 'tutor').replace(/[<>"'&]/g, '');
            
            rescheduleInfo = `
                <div class="session-detail" style="color: var(--warning); font-weight: 500;">
                    <i class="fas fa-exchange-alt"></i>
                    <span>Reschedule Requested by ${requestedBy}: ${newFormattedDate} at ${newFormattedTime}</span>
                </div>
                <div class="session-detail">
                    <i class="fas fa-comment"></i>
                    <span>Reason: ${reason}</span>
                </div>
            `;
        }
        
        html += `
            <div class="session-card ${booking.hasPendingReschedule ? 'reschedule-requested' : ''}" id="booking-${sanitizedId}">
                <div class="session-header">
                    <div class="session-title">${sanitizedSubject}</div>
                    <div class="session-date">${formattedDate} at ${formattedTime}</div>
                </div>
                <div class="session-details">
                    <div class="session-detail">
                        <i class="fas fa-user-tie"></i>
                        <span>Tutor: ${tutorName}</span>
                    </div>
                    <div class="session-detail">
                        <i class="fas fa-clock"></i>
                        <span>Duration: ${duration} hours</span>
                    </div>
                    <div class="session-detail">
                        <i class="fas fa-video"></i>
                        <span>Type: ${sessionType}</span>
                    </div>
                    <div class="session-detail">
                        <i class="fas fa-hourglass-half"></i>
                        <span>Status: <span class="status-badge ${getStatusClass(booking.status)}">${status}</span></span>
                    </div>
                    ${rescheduleInfo}
                </div>
                <div class="session-actions">
                    ${booking.hasPendingReschedule ? 
                        `<button class="btn-success" data-session-id="${sanitizedId}" data-action="accept-reschedule">Accept Reschedule</button>
                         <button class="btn-danger" data-session-id="${sanitizedId}" data-action="decline-reschedule">Decline Reschedule</button>` :
                        `<button class="btn-outline" data-session-id="${sanitizedId}" data-action="cancel">Cancel</button>`
                    }
                    ${canJoin && meetLinkAvailable ? 
                        `<button class="btn-primary" data-session-id="${sanitizedId}" data-action="join">
                            <i class="fas fa-video"></i> Join Session
                         </button>` : ''}
                    ${canJoin && booking.status === 'confirmed' && !meetLinkAvailable ? 
                        `<button class="btn-outline" disabled>
                            <i class="fas fa-clock"></i> Awaiting Meeting Link
                         </button>` : ''}
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;

    // Add informational text
    const infoText = document.createElement('div');
    infoText.className = 'booking-info-text';
    infoText.innerHTML = '<i class="fas fa-info-circle"></i> Join Session button will appear once status is confirmed and it\'s within 15 minutes of your session time.';
    container.appendChild(infoText);
    
    // Set up the event listener only once
    if (!bookingsContainerListener) {
        bookingsContainerListener = function(e) {
            const sessionId = e.target.getAttribute('data-session-id');
            const action = e.target.getAttribute('data-action');
            
            if (!sessionId || !action) return;
            
            if (!/^[a-zA-Z0-9_-]+$/.test(sessionId)) {
                alert('Invalid session ID.');
                return;
            }
            
            switch(action) {
                case 'join':
                    joinSession(sessionId);
                    break;
                case 'cancel':
                    cancelBooking(sessionId);
                    break;
                case 'accept-reschedule':
                    respondToReschedule(sessionId, 'accept');
                    break;
                case 'decline-reschedule':
                    respondToReschedule(sessionId, 'decline');
                    break;
            }
        };
        
        container.addEventListener('click', bookingsContainerListener);
    }
}
  
// LoadUserBookings function that uses the proper structure:
function loadUserBookings() {
    const userId = auth.currentUser.uid;
    
    // Query sessions including reschedule_requested status
    db.collection('bookedSessions')
        .where('studentId', '==', userId)
        .where('status', 'in', ['confirmed', 'pending', 'reschedule_requested'])
        .orderBy('date', 'asc')
        .get()
        .then((querySnapshot) => {
            // Filter client-side to include sessions that haven't ended yet
            const filteredSessions = [];
            const now = new Date();
            
            querySnapshot.forEach(doc => {
                const booking = doc.data();
                const bookingId = doc.id;
                
                // Convert Firestore Timestamps to Date objects
                if (booking.date && typeof booking.date.toDate === 'function') {
                    booking.date = booking.date.toDate();
                }
                if (booking.proposedNewDate && typeof booking.proposedNewDate.toDate === 'function') {
                    booking.proposedNewDate = booking.proposedNewDate.toDate();
                }
                
                // Calculate session end time (start time + duration)
                const sessionEndTime = new Date(booking.date);
                const durationHours = parseFloat(booking.duration) || 1.5;
                sessionEndTime.setHours(sessionEndTime.getHours() + durationHours);
                
                // Include sessions that haven't ended yet
                if (sessionEndTime > now) {
                    filteredSessions.push({
                        id: bookingId,
                        ...booking
                    });
                }
            });
            
            updateUpcomingSessionsCount(filteredSessions.length);
            
            // Check for pending reschedule requests in the booking data
            const bookingsWithRescheduleInfo = filteredSessions.map(booking => {
                const hasPendingReschedule = booking.rescheduleRequested && 
                                           booking.status === 'reschedule_requested';
                
                return {
                    ...booking,
                    hasPendingReschedule: hasPendingReschedule,
                    rescheduleRequest: hasPendingReschedule ? {
                        requestedDate: booking.proposedNewDate, // Use proposedNewDate field
                        reason: booking.rescheduleReason || 'No reason provided',
                        requestedBy: booking.rescheduleRequestedBy || 'tutor'
                    } : null
                };
            });
            
            loadBookingsDisplay(bookingsWithRescheduleInfo);
        })
        .catch((error) => {
            console.error('Error loading booked sessions:', error);
            const container = document.getElementById('bookingsContainer');
            if (container) {
                container.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-circle"></i><h3>Error Loading Bookings</h3><p>Failed to load your bookings. Please try again later.</p></div>';
            }
        });
}

// Show notification when session is confirmed
function showSessionConfirmedNotification(session) {
    const notification = {
        title: 'Session Confirmed!',
        message: `Your ${session.subject} session with ${session.tutorName} has been confirmed.`,
        type: 'session_confirmed',
        sessionId: session.id
    };
    
    // Use your notification system or show a simple alert
    if (window.notificationSystem) {
        window.notificationSystem.showToastNotification(notification);
    } else {
        alert(notification.message);
    }
}

// Setup session listeners
function setupSessionListeners() {
    const userId = auth.currentUser.uid;
    
    // Store the unsubscribe function to clean up later
    window.sessionListenerUnsubscribe = db.collection('bookedSessions')
        .where('studentId', '==', userId)
        .where('status', 'in', ['pending', 'confirmed'])
        .onSnapshot((snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === 'modified') {
                    const session = change.doc.data();
                    const oldSession = change.doc.previous.data();
                    
                    // Only reload if status changed TO confirmed or meeting link was added
                    if ((session.status === 'confirmed' && oldSession?.status !== 'confirmed') ||
                        (session.meetLink && !oldSession?.meetLink)) {
                        console.log('Session updated, reloading bookings...');
                        loadUserBookings();
                    }
                }
            });
        });
}

// Cleanup session listeners
function cleanupSessionListeners() {
    if (window.sessionListenerUnsubscribe) {
        window.sessionListenerUnsubscribe();
        window.sessionListenerUnsubscribe = null;
    }
}

// Missing function definitions that were causing errors
function setupActivityListeners() {
    console.log('setupActivityListeners called - placeholder implementation');
    // Add your activity listeners here
}

function setupProfileEditing() {
    console.log('setupProfileEditing function called - placeholder implementation');
}

function resetInactivityTimer() {
    console.log('resetInactivityTimer function called - placeholder implementation');
}

// Event listeners for page lifecycle
document.addEventListener('DOMContentLoaded', function() {
    if (auth.currentUser) {
        setupSessionListeners();
        setupActivityListeners(); // Now this function exists
    }
});

window.addEventListener('beforeunload', cleanupSessionListeners);
        
        // Initialize session listeners when dashboard loads
auth.onAuthStateChanged((user) => {
  if (user) {
    currentUser = user;
    
    // Try to initialize Cloud Functions with error handling
    try {
      if (typeof firebase.functions !== 'undefined') {
        const functions = firebase.functions();
        window.createPackageCheckout = functions.httpsCallable('createPackageCheckout');
        console.log('Cloud Functions initialized successfully');
      } else {
        throw new Error('Functions SDK not loaded');
      }
    } catch (error) {
      console.error('Cloud Functions initialization failed:', error);
      // Provide fallback
      window.createPackageCheckout = () => {
        alert('Package purchasing is temporarily unavailable. Please contact support.');
        return Promise.reject('Functions not available');
      };
    }
    
    loadDashboardData().then(() => {
      setupSessionListeners();
      setupActivityListeners();
      
      // SPECIFIC INITIALIZATION CODE THAT SHOULD BE HERE:
      initDashboard(); // Your main dashboard initialization
      loadPackageBalance(); // Load package balance
      setupProfileEditing(); // Profile editing handlers
      resetInactivityTimer(); // Activity tracking
      // INITIALIZE CHAT SYSTEM
      setTimeout(() => {
        initChatSystem();
      }, 2000);
      // Add any other specific initialization functions you have
      
      console.log('Dashboard fully initialized');
    });
  } else {
    window.location.href = 'student-login.html';
  }
});
  
//...............................................................................................
// My Bookings Section ends here. All JS functionalities of the My Bookings section ends here
//...............................................................................................


//...............................................................................................
// Sessions History Section starts here. All JS functionalities of the Sessions History section starts here
//...............................................................................................

// =============================================
// SESSIONS HISTORY PAGINATION AND CARD VIEW
// =============================================

// Global variables for pagination
let currentPage = 1;
let itemsPerPage = 6;
let totalPages = 1;
let allSessionsData = [];
let filteredSessionsData = [];
let currentView = 'cards';

// Function to load sessions with pagination
function loadSessions(limit = 50, loadMore = false) {
  const cardsContainer = document.getElementById('sessionsCardsContainer');
  const tableContainer = document.getElementById('sessionsContainer');
  const paginationContainer = document.getElementById('paginationContainer');

  if (!cardsContainer) return;

  if (typeof db === 'undefined' || typeof auth === 'undefined') {
    cardsContainer.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-triangle"></i><h3>System Error</h3><p>Please refresh the page.</p></div>';
    return;
  }

  if (!auth.currentUser) {
    cardsContainer.innerHTML = '<div class="error-state"><i class="fas fa-user"></i><h3>Authentication Required</h3><p>Please log in to view session history.</p></div>';
    return;
  }

  if (!loadMore) {
    if (currentView === 'cards') {
      cardsContainer.innerHTML = '<div class="spinner" id="sessionsSpinner"></div>';
    } else {
      tableContainer.innerHTML = '<div class="spinner"></div>';
    }
    paginationContainer.style.display = 'none';
  }

  let query = db.collection('bookedSessions')
    .where('studentId', '==', auth.currentUser.uid)
    .orderBy('date', 'desc')
    .limit(limit);

  query.get().then(snapshot => {
    if (snapshot.empty) {
      showNoSessionsMessage();
      return;
    }

    allSessionsData = [];
    snapshot.forEach(doc => {
      const sessionData = doc.data();
      allSessionsData.push({
        id: doc.id,
        ...sessionData
      });
    });

    applyFiltersAndPaginate();
    
  }).catch(error => {
    console.error('Error loading sessions:', error);
    showErrorMessage();
  });
}

function applyFiltersAndPaginate() {
  filterSessions();
  setupPagination();
  displayCurrentPage();
}

function filterSessions() {
  const timeFilter = document.getElementById('historyFilter').value;
  const actionFilter = document.getElementById('actionTypeFilter').value;
  
  filteredSessionsData = allSessionsData.filter(session => {
    let matchesTime = true;
    let matchesAction = true;
    
    if (timeFilter !== 'all') {
      const sessionDate = session.date.toDate();
      const now = new Date();
      let startDate;
      
      switch(timeFilter) {
        case 'month':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          break;
        case '3months':
          startDate = new Date(now);
          startDate.setMonth(now.getMonth() - 3);
          break;
        case 'year':
          startDate = new Date(now.getFullYear(), 0, 1);
          break;
        default:
          startDate = null;
      }
      
      if (startDate && sessionDate < startDate) {
        matchesTime = false;
      }
    }
    
    if (actionFilter !== 'all') {
      const { actionType } = getActionTimestamp(session);
      let filterValue = actionFilter.toLowerCase();
      
      if (filterValue === 'student booked') {
        matchesAction = actionType.toLowerCase() === 'student booked';
      } else if (filterValue === 'student confirmed') {
        matchesAction = actionType.toLowerCase() === 'student confirmed';
      } else if (filterValue === 'tutor confirmed') {
        matchesAction = actionType.toLowerCase() === 'tutor confirmed';
      } else if (filterValue === 'completed') {
        matchesAction = actionType.toLowerCase() === 'completed';
      } else if (filterValue === 'student cancelled') {
        matchesAction = actionType.toLowerCase() === 'student cancelled';
      } else if (filterValue === 'tutor cancelled') {
        matchesAction = actionType.toLowerCase() === 'tutor cancelled';
      } else if (filterValue === 'auto-confirmed') {
        matchesAction = actionType.toLowerCase() === 'auto-confirmed';
      } else if (filterValue === 'student reschedule request') {
        matchesAction = actionType.toLowerCase() === 'student reschedule request';
      } else if (filterValue === 'tutor reschedule request') {
        matchesAction = actionType.toLowerCase() === 'tutor reschedule request';
      } else if (filterValue === 'rescheduled') {
        matchesAction = actionType.toLowerCase() === 'rescheduled';
      } else {
        matchesAction = true;
      }
    }
    
    return matchesTime && matchesAction;
  });
  
  filteredSessionsData.sort((a, b) => {
    const aDate = a.date.toDate();
    const bDate = b.date.toDate();
    return bDate - aDate;
  });
}

function setupPagination() {
  totalPages = Math.ceil(filteredSessionsData.length / itemsPerPage);
  currentPage = 1;
  
  const paginationContainer = document.getElementById('paginationContainer');
  const pageNumbersContainer = document.getElementById('pageNumbers');
  const paginationInfo = document.getElementById('paginationInfo');
  
  if (filteredSessionsData.length === 0) {
    paginationContainer.style.display = 'none';
    return;
  }
  
  paginationContainer.style.display = 'flex';
  
  const startItem = (currentPage - 1) * itemsPerPage + 1;
  const endItem = Math.min(currentPage * itemsPerPage, filteredSessionsData.length);
  paginationInfo.textContent = `Showing ${startItem}-${endItem} of ${filteredSessionsData.length} sessions`;
  
  pageNumbersContainer.innerHTML = '';
  
  let startPage = Math.max(1, currentPage - 2);
  let endPage = Math.min(totalPages, startPage + 4);
  
  if (endPage - startPage < 4) {
    startPage = Math.max(1, endPage - 4);
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = `pagination-page ${i === currentPage ? 'active' : ''}`;
    pageBtn.textContent = i;
    pageBtn.onclick = () => goToPage(i);
    pageNumbersContainer.appendChild(pageBtn);
  }
  
  document.getElementById('firstPageBtn').disabled = currentPage === 1;
  document.getElementById('prevPageBtn').disabled = currentPage === 1;
  document.getElementById('nextPageBtn').disabled = currentPage === totalPages;
  document.getElementById('lastPageBtn').disabled = currentPage === totalPages;
}

function goToPage(page) {
  if (page < 1 || page > totalPages) return;
  
  currentPage = page;
  displayCurrentPage();
  setupPagination();
}

function displayCurrentPage() {
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentPageData = filteredSessionsData.slice(startIndex, endIndex);
  
  if (currentView === 'cards') {
    displaySessionsAsCards(currentPageData);
  } else {
    displaySessionsAsTable(currentPageData);
  }
}

function displaySessionsAsCards(sessions) {
  const container = document.getElementById('sessionsCardsContainer');
  
  if (sessions.length === 0) {
    container.innerHTML = '<div class="empty-state"><i class="fas fa-history"></i><h3>No Sessions Found</h3><p>No sessions match your current filters.</p></div>';
    return;
  }
  
  let html = '';
  
  sessions.forEach(session => {
    const sessionDate = session.date.toDate();
    const formattedDate = sessionDate.toLocaleDateString();
    const formattedTime = sessionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    const { actionTime, actionType } = getActionTimestamp(session);
    const actionDate = actionTime.toLocaleDateString();
    const actionTimeFormatted = actionTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    let cardClass = 'session-history-card';
    if (session.status === 'cancelled') {
      cardClass += ' cancelled';
    } else if (session.status === 'completed') {
      cardClass += ' completed';
    } else if (session.status === 'pending') {
      cardClass += ' pending';
    } else if (session.status === 'rescheduled') {
      cardClass += ' rescheduled';
    }
    
    html += `
      <div class="${cardClass}">
        <div class="session-history-header">
          <div class="session-history-subject">${session.subject || 'No subject specified'}</div>
          <div class="session-history-date">
            <div>${formattedDate}</div>
            <div>${formattedTime}</div>
          </div>
        </div>
        
        <div class="session-history-details">
          <div class="session-history-detail">
            <i class="fas fa-user-tie"></i>
            <span>Tutor: ${session.tutorName || 'Tutor Name Not Available'}</span>
          </div>
          <div class="session-history-detail">
            <i class="fas fa-clock"></i>
            <span>Duration: ${session.duration || '1'} hours</span>
          </div>
          <div class="session-history-detail">
            <i class="fas fa-video"></i>
            <span>Type: ${session.sessionType === 'in-person' ? 'In-Person' : 'Online'}</span>
          </div>
          <div class="session-history-detail">
            <i class="fas fa-hourglass-half"></i>
            <span>Status: <span class="status-badge ${getStatusClass(session.status)}">${session.status || 'unknown'}</span></span>
          </div>
          <div class="session-history-detail">
            <i class="fas fa-calendar-check"></i>
            <span>Action: ${actionType}</span>
          </div>
          <div class="session-history-detail">
            <i class="fas fa-calendar-alt"></i>
            <span>Action Date: ${actionDate} ${actionTimeFormatted}</span>
          </div>
        </div>
        
        ${session.notes ? `
          <div class="session-history-detail">
            <i class="fas fa-sticky-note"></i>
            <span>Notes: ${session.notes}</span>
          </div>
        ` : ''}
        
        <div class="session-history-actions">
          ${session.meetLink && session.status === 'completed' ? `
            <button class="btn-outline btn-small" onclick="window.open('${session.meetLink}', '_blank')">
              <i class="fas fa-external-link-alt"></i> Meeting Link
            </button>
          ` : ''}
          
          ${session.status === 'completed' ? `
            <button class="btn-primary btn-small" onclick="rateSession('${session.id}')">
              <i class="fas fa-star"></i> Rate Session
            </button>
          ` : ''}
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function switchView(view) {
  currentView = view;
  
  document.querySelectorAll('.view-toggle-btn').forEach(btn => {
    btn.classList.toggle('active', btn.getAttribute('data-view') === view);
  });
  
  document.getElementById('sessionsCardsContainer').style.display = 
    view === 'cards' ? 'grid' : 'none';
  document.getElementById('sessionsTableContainer').style.display = 
    view === 'table' ? 'block' : 'none';
  
  displayCurrentPage();
}

function showNoSessionsMessage() {
  const cardsContainer = document.getElementById('sessionsCardsContainer');
  const tableContainer = document.getElementById('sessionsContainer');
  const paginationContainer = document.getElementById('paginationContainer');
  
  const message = '<div class="empty-state"><i class="fas fa-history"></i><h3>No Session History</h3><p>You haven\'t had any sessions yet.</p></div>';
  
  if (currentView === 'cards') {
    cardsContainer.innerHTML = message;
  } else {
    tableContainer.innerHTML = message;
  }
  
  paginationContainer.style.display = 'none';
}

function showErrorMessage() {
  const cardsContainer = document.getElementById('sessionsCardsContainer');
  const tableContainer = document.getElementById('sessionsContainer');
  
  const message = '<div class="error-state"><i class="fas fa-exclamation-triangle"></i><h3>Error Loading Sessions</h3><p>Please try again later.</p></div>';
  
  if (currentView === 'cards') {
    cardsContainer.innerHTML = message;
  } else {
    tableContainer.innerHTML = message;
  }
}

// Update the main load function
function loadUserSessionHistory() {
  console.log('Loading user session history with pagination...');
  loadSessions();
}

// Add event listeners
document.addEventListener('DOMContentLoaded', function() {
  // View toggle buttons
  document.querySelectorAll('.view-toggle-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      switchView(this.getAttribute('data-view'));
    });
  });
  
  // Pagination buttons
  document.getElementById('firstPageBtn').addEventListener('click', () => goToPage(1));
  document.getElementById('prevPageBtn').addEventListener('click', () => goToPage(currentPage - 1));
  document.getElementById('nextPageBtn').addEventListener('click', () => goToPage(currentPage + 1));
  document.getElementById('lastPageBtn').addEventListener('click', () => goToPage(totalPages));
  
  // Filter change events
  document.getElementById('historyFilter').addEventListener('change', applyFiltersAndPaginate);
  document.getElementById('actionTypeFilter').addEventListener('change', applyFiltersAndPaginate);
});

function rateSession(sessionId) {
  alert(`Rating functionality for session ${sessionId} would be implemented here.`);
}

  // Missing function: getActionTimestamp
function getActionTimestamp(session) {
    let actionTime = new Date();
    let actionType = 'Unknown';
    
    if (session.cancelledAt) {
        actionTime = session.cancelledAt.toDate();
        if (session.cancelledBy === 'student') {
            actionType = 'Student Cancelled';
        } else if (session.cancelledBy === 'tutor') {
            actionType = 'Tutor Cancelled';
        } else {
            actionType = 'Cancelled';
        }
    } else if (session.completedAt) {
        actionTime = session.completedAt.toDate();
        actionType = 'Completed';
    } else if (session.rescheduleAcceptedAt) {
        actionTime = session.rescheduleAcceptedAt.toDate();
        actionType = 'Rescheduled';
    } else if (session.rescheduleRequestedAt) {
        actionTime = session.rescheduleRequestedAt.toDate();
        if (session.rescheduleRequestedBy === 'tutor') {
            actionType = 'Tutor Reschedule Request';
        } else if (session.rescheduleRequestedBy === 'student') {
            actionType = 'Student Reschedule Request';
        } else {
            actionType = 'Reschedule Requested';
        }
    } else if (session.confirmedAt) {
        actionTime = session.confirmedAt.toDate();
        actionType = 'Tutor Confirmed';
    } else if (session.bookedAt) {
        actionTime = session.bookedAt.toDate();
        actionType = 'Student Booked';
    } else {
        actionTime = session.date.toDate();
        actionType = 'Scheduled';
    }
    
    return { actionTime, actionType };
}

// Missing function: displaySessionsAsTable
function displaySessionsAsTable(sessions) {
    const container = document.getElementById('sessionsContainer');
    if (!container) return;
    
    if (sessions.length === 0) {
        container.innerHTML = '<div class="empty-state">No sessions found</div>';
        return;
    }
    
    let html = `
        <table class="sessions-table">
            <thead>
                <tr>
                    <th>Session Date</th>
                    <th>Tutor</th>
                    <th>Subject</th>
                    <th>Duration</th>
                    <th>Status</th>
                    <th>Action Type</th>
                </tr>
            </thead>
            <tbody>
    `;

    sessions.forEach(session => {
        const sessionDate = session.date.toDate();
        const formattedDate = sessionDate.toLocaleDateString();
        const { actionTime, actionType } = getActionTimestamp(session);
        
        html += `
            <tr>
                <td>${formattedDate}</td>
                <td>${session.tutorName || 'Unknown'}</td>
                <td>${session.subject || 'No subject'}</td>
                <td>${session.duration || '1'} hours</td>
                <td><span class="status-badge ${getStatusClass(session.status)}">${session.status}</span></td>
                <td>${actionType}</td>
            </tr>
        `;
    });
    
    html += '</tbody></table>';
    container.innerHTML = html;
}

// Missing function: getStatusClass
function getStatusClass(status) {
    switch(status) {
        case 'confirmed':
        case 'completed':
            return 'status-verified';
        case 'pending':
            return 'status-pending';
        case 'cancelled':
            return 'status-cancelled';
        case 'reschedule_requested':
            return 'status-reschedule-requested';
        default:
            return 'status-pending';
    }
}

// Missing function: showNoSessionsMessage
function showNoSessionsMessage() {
    const cardsContainer = document.getElementById('sessionsCardsContainer');
    const tableContainer = document.getElementById('sessionsContainer');
    
    const message = '<div class="empty-state"><i class="fas fa-history"></i><h3>No Session History</h3><p>You haven\'t had any sessions yet.</p></div>';
    
    if (currentView === 'cards') {
        if (cardsContainer) cardsContainer.innerHTML = message;
    } else {
        if (tableContainer) tableContainer.innerHTML = message;
    }
}

// Missing function: showErrorMessage
function showErrorMessage() {
    const cardsContainer = document.getElementById('sessionsCardsContainer');
    const tableContainer = document.getElementById('sessionsContainer');
    
    const message = '<div class="error-state"><i class="fas fa-exclamation-triangle"></i><h3>Error Loading Sessions</h3><p>Please try again later.</p></div>';
    
    if (currentView === 'cards') {
        if (cardsContainer) cardsContainer.innerHTML = message;
    } else {
        if (tableContainer) tableContainer.innerHTML = message;
    }
}

  
//...........................................................................................................
//Sessions History Section ends here. All JS functionalities of the Sessions History section ends here
//............................................................................................................

// =============================================
// NOTIFICATION BELL FUNCTIONALITY STARTS HERE (REAL DATA VERSION)
// =============================================

// =============================================
// PRODUCTION-READY NOTIFICATION SYSTEM (OPTIMIZED)
// =============================================

class NotificationSystem {
    constructor() {
        this.notifications = [];
        this.unreadCount = 0;
        this.realtimeListener = null;
        this.isInitialized = false;
        this.isLoading = false;
        
        // Debounce variables
        this.updateTimeout = null;
        this.clickHandlers = new Map();
        
        // Bind methods to maintain context
        this.handleBellClick = this.handleBellClick.bind(this);
        this.handleOutsideClick = this.handleOutsideClick.bind(this);
        this.handleKeydown = this.handleKeydown.bind(this);
        this.handleMarkAllRead = this.handleMarkAllRead.bind(this);
        this.handleClearAll = this.handleClearAll.bind(this);
        this.handleRealtimeUpdate = this.handleRealtimeUpdate.bind(this);
        this.handleRealtimeError = this.handleRealtimeError.bind(this);
    }

    // Initialize notification system with proper error handling
    async initialize() {
        if (this.isInitialized) {
            console.warn('Notification system already initialized');
            return;
        }

        if (this.isLoading) {
            console.warn('Notification system is already loading');
            return;
        }

        this.isLoading = true;

        try {
            await this.validateDependencies();
            this.setupDOMElements();
            await this.loadNotifications();
            this.startRealtimeListener();
            this.setupEventListeners();
            this.isInitialized = true;
            this.isLoading = false;
            
            console.log('Notification system initialized successfully');
        } catch (error) {
            this.isLoading = false;
            this.handleInitializationError(error);
            // Don't throw - allow system to work in degraded mode
        }
    }

    // Validate required dependencies
    async validateDependencies() {
        if (typeof db === 'undefined') {
            throw new Error('Firestore database not available');
        }
        
        if (typeof currentUser === 'undefined' || !currentUser?.uid) {
            throw new Error('User not authenticated');
        }
    }

    // Setup DOM elements with proper error handling
    setupDOMElements() {
        try {
            this.createNotificationDropdown();
            this.injectStyles();
        } catch (error) {
            throw new Error(`DOM setup failed: ${error.message}`);
        }
    }

    // Create notification dropdown with accessible markup
    createNotificationDropdown() {
        const existingDropdown = document.getElementById('notificationDropdown');
        if (existingDropdown) {
            existingDropdown.remove();
        }

        const dropdown = document.createElement('div');
        dropdown.id = 'notificationDropdown';
        dropdown.className = 'notification-dropdown hidden';
        dropdown.setAttribute('role', 'dialog');
        dropdown.setAttribute('aria-label', 'Notifications');
        dropdown.setAttribute('aria-modal', 'true');
        
        dropdown.innerHTML = `
            <div class="notification-header">
                <h4 class="notification-title">Notifications</h4>
                <div class="notification-actions">
                    <button id="markAllReadBtn" class="btn-outline btn-small" 
                            aria-label="Mark all notifications as read">
                        Mark All Read
                    </button>
                    <button id="clearNotificationsBtn" class="btn-outline btn-small" 
                            aria-label="Clear all notifications">
                        Clear All
                    </button>
                </div>
            </div>
            <div class="notification-list" id="notificationList" role="list">
                <div class="notification-loading">
                    <div class="loading-spinner" aria-label="Loading notifications"></div>
                    <span>Loading notifications...</span>
                </div>
            </div>
            <div class="notification-footer">
                <span id="notificationFooterText" aria-live="polite">Loading...</span>
            </div>
        `;

        document.body.appendChild(dropdown);
    }

    // Inject CSS styles for maintainability
    injectStyles() {
        const styleId = 'notification-system-styles';
        if (document.getElementById(styleId)) return;

        const styles = `
            .notification-dropdown {
                position: absolute;
                top: 60px;
                right: 10px;
                width: min(400px, 90vw);
                max-height: 500px;
                background: var(--background-primary, #ffffff);
                border: 1px solid var(--border-color, #e0e0e0);
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            .notification-dropdown.hidden {
                display: none;
            }
            
            .notification-dropdown.visible {
                display: flex;
            }
            
            .notification-header {
                padding: 1rem;
                border-bottom: 1px solid var(--border-color, #e0e0e0);
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: var(--background-secondary, #f8f9fa);
            }
            
            .notification-title {
                margin: 0;
                color: var(--text-primary, #333333);
                font-size: 1.1rem;
                font-weight: 600;
            }
            
            .notification-actions {
                display: flex;
                gap: 0.5rem;
            }
            
            .notification-list {
                flex: 1;
                overflow-y: auto;
                max-height: 300px;
            }
            
            .notification-loading {
                padding: 2rem;
                text-align: center;
                color: var(--text-secondary, #666666);
            }
            
            .loading-spinner {
                width: 24px;
                height: 24px;
                border: 2px solid var(--border-color, #e0e0e0);
                border-top: 2px solid var(--primary-color, #007bff);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 0.5rem;
            }
            
            .notification-item {
                padding: 0.75rem 1rem;
                border-bottom: 1px solid var(--border-light, #f0f0f0);
                cursor: pointer;
                transition: background-color 0.2s ease;
                display: flex;
                align-items: flex-start;
                gap: 0.75rem;
            }
            
            .notification-item:hover {
                background-color: var(--background-hover, #f5f5f5);
            }
            
            .notification-item.unread {
                background-color: var(--background-accent, #f0f7ff);
            }
            
            .notification-item:focus {
                outline: 2px solid var(--primary-color, #007bff);
                outline-offset: -2px;
            }
            
            .notification-icon {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                flex-shrink: 0;
            }
            
            .notification-content {
                flex: 1;
                min-width: 0;
            }
            
            .notification-title-text {
                font-weight: 600;
                color: var(--text-primary, #333333);
                margin-bottom: 0.25rem;
                word-wrap: break-word;
            }
            
            .notification-message {
                font-size: 0.9rem;
                color: var(--text-secondary, #666666);
                line-height: 1.4;
                margin-bottom: 0.25rem;
            }
            
            .notification-time {
                font-size: 0.8rem;
                color: var(--text-tertiary, #999999);
            }
            
            .unread-indicator {
                width: 8px;
                height: 8px;
                background: var(--accent-color, #4361ee);
                border-radius: 50%;
                margin-left: 0.5rem;
                flex-shrink: 0;
                margin-top: 0.5rem;
            }
            
            .notification-footer {
                padding: 0.75rem 1rem;
                border-top: 1px solid var(--border-light, #f0f0f0);
                text-align: center;
                background: var(--background-secondary, #f8f9fa);
            }
            
            .notification-empty {
                padding: 2rem;
                text-align: center;
                color: var(--text-secondary, #666666);
            }
            
            .notification-error {
                padding: 1rem;
                text-align: center;
                color: var(--error-color, #dc3545);
            }
            
            .btn-retry {
                margin-top: 0.5rem;
                padding: 0.5rem 1rem;
                background: var(--primary-color, #007bff);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            
            .btn-retry:hover {
                background: var(--primary-dark, #0056b3);
            }
            
            .hidden {
                display: none !important;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            
            @media (max-width: 480px) {
                .notification-dropdown {
                    right: 5px;
                    left: 5px;
                    width: auto;
                }
            }
        `;

        const styleElement = document.createElement('style');
        styleElement.id = styleId;
        styleElement.textContent = styles;
        document.head.appendChild(styleElement);
    }

    // Load notifications with efficient batch operations
    async loadNotifications() {
        if (this.isLoading) return;
        
        this.isLoading = true;
        this.showLoadingState();
        
        try {
            const notificationsSnapshot = await this.fetchNotifications();
            
            if (notificationsSnapshot && !notificationsSnapshot.empty) {
                const sessionsMap = await this.preloadSessionData(notificationsSnapshot);
                this.processNotifications(notificationsSnapshot, sessionsMap);
            } else {
                this.notifications = [];
                this.unreadCount = 0;
            }
            
            this.updateUI();
            
        } catch (error) {
            this.handleLoadError(error);
        } finally {
            this.isLoading = false;
        }
    }

    // Fetch notifications with pagination and security
    async fetchNotifications() {
        try {
            const snapshot = await db.collection('notifications')
                .where('userId', '==', currentUser.uid)
                .orderBy('createdAt', 'desc')
                .limit(20)
                .get();

            return snapshot;
        } catch (error) {
            if (error.code === 'permission-denied') {
                throw new Error('Access to notifications denied');
            } else if (error.code === 'failed-precondition') {
                // Index missing error - fallback to simpler query
                console.warn('Firestore index missing, using fallback query');
                return await this.fetchNotificationsFallback();
            } else if (error.code === 'resource-exhausted') {
                throw new Error('Service temporarily unavailable');
            }
            throw error;
        }
    }

    // Fallback query without complex where clauses
    async fetchNotificationsFallback() {
        try {
            // Try without ordering first
            const snapshot = await db.collection('notifications')
                .where('userId', '==', currentUser.uid)
                .limit(20)
                .get();

            // Sort client-side
            const sortedDocs = snapshot.docs.sort((a, b) => {
                const aTime = a.data().createdAt?.toDate() || new Date(0);
                const bTime = b.data().createdAt?.toDate() || new Date(0);
                return bTime - aTime;
            });

            return {
                empty: sortedDocs.length === 0,
                docs: sortedDocs
            };
        } catch (error) {
            // Last resort - get all and filter client-side
            console.warn('Using client-side filtering fallback');
            const snapshot = await db.collection('notifications')
                .limit(50)
                .get();

            const userNotifications = snapshot.docs
                .filter(doc => doc.data().userId === currentUser.uid)
                .sort((a, b) => {
                    const aTime = a.data().createdAt?.toDate() || new Date(0);
                    const bTime = b.data().createdAt?.toDate() || new Date(0);
                    return bTime - aTime;
                });

            return {
                empty: userNotifications.length === 0,
                docs: userNotifications
            };
        }
    }

    // Preload session data efficiently
    async preloadSessionData(notificationsSnapshot) {
        if (!notificationsSnapshot || notificationsSnapshot.empty) {
            return new Map();
        }

        const sessionIds = new Set();
        const docs = notificationsSnapshot.docs || [];

        // Collect all session IDs from notifications
        docs.forEach(doc => {
            const notification = doc.data();
            if (notification.relatedSessionId) {
                sessionIds.add(notification.relatedSessionId);
            }
        });

        if (sessionIds.size === 0) return new Map();

        try {
            const sessionIdsArray = Array.from(sessionIds);
            const sessionsMap = new Map();

            // Load sessions in batches of 10 (Firestore limit)
            for (let i = 0; i < sessionIdsArray.length; i += 10) {
                const chunk = sessionIdsArray.slice(i, i + 10);
                const sessionsSnapshot = await db.collection('bookedSessions')
                    .where('__name__', 'in', chunk)
                    .get();

                sessionsSnapshot.docs.forEach(doc => {
                    sessionsMap.set(doc.id, doc.data());
                });
            }

            return sessionsMap;
        } catch (error) {
            console.warn('Failed to load session data:', error);
            return new Map();
        }
    }

    // Process notifications with enriched data
    processNotifications(snapshot, sessionsMap) {
        this.notifications = [];

        if (!snapshot || snapshot.empty) {
            return;
        }

        const docs = snapshot.docs || [];
        docs.forEach(doc => {
            const notification = this.enrichNotificationData(doc, sessionsMap);
            this.notifications.push(notification);
        });

        this.unreadCount = this.notifications.filter(n => !n.isRead).length;
    }

    // Enrich notification with related data
    enrichNotificationData(doc, sessionsMap) {
        const data = doc.data();
        const notification = { 
            id: doc.id, 
            ...data,
            sessionData: null
        };

        // Add session data if available
        if (notification.relatedSessionId && sessionsMap) {
            notification.sessionData = sessionsMap.get(notification.relatedSessionId);
        }

        return notification;
    }

    // Update UI components
    updateUI() {
        this.updateBadge();
        this.updateDropdownContent();
        this.updateFooter();
    }

    // Update notification badge
    updateBadge() {
  const badge = document.getElementById('notificationCount');
  if (!badge) {
    console.warn('Notification badge element not found');
    return;
  }

  if (this.unreadCount > 0) {
    badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount.toString();
    badge.style.display = 'flex'; // Use flex instead of removing hidden class
    badge.setAttribute('aria-label', `${this.unreadCount} unread notifications`);
    
    // Add pulse animation for new notifications
    badge.style.animation = 'pulse 1s ease-in-out';
  } else {
    badge.style.display = 'none';
    badge.setAttribute('aria-label', 'No unread notifications');
  }
}

    // Update dropdown content
updateDropdownContent() {
    const list = document.getElementById('notificationList');
    if (!list) return;

    if (this.notifications.length === 0) {
        list.innerHTML = this.getEmptyStateHTML();
        return;
    }

    // Ensure notifications are sorted by date (newest first)
    const sortedNotifications = [...this.notifications].sort((a, b) => {
        const aTime = a.createdAt?.toDate()?.getTime() || 0;
        const bTime = b.createdAt?.toDate()?.getTime() || 0;
        return bTime - aTime; // Descending order (newest first)
    });

    list.innerHTML = sortedNotifications.map(notification => 
        this.getNotificationHTML(notification)
    ).join('');

    this.attachNotificationHandlers();
}
  
    // Get notification HTML template
    getNotificationHTML(notification) {
        const timeAgo = this.getTimeAgo(notification.createdAt);
        const isUnread = !notification.isRead;
        const message = this.generateNotificationMessage(notification);

        return `
            <div class="notification-item ${isUnread ? 'unread' : ''}" 
                 data-notification-id="${notification.id}"
                 data-notification-type="${notification.type}"
                 data-session-id="${notification.relatedSessionId || ''}"
                 role="listitem"
                 tabindex="0">
                <div class="notification-icon" style="background: ${this.getNotificationColor(notification.type)}">
                    <i class="${this.getNotificationIcon(notification.type)}" aria-hidden="true"></i>
                </div>
                <div class="notification-content">
                    <div class="notification-title-text">${this.escapeHtml(notification.title)}</div>
                    <div class="notification-message">${this.escapeHtml(message)}</div>
                    <div class="notification-time">${timeAgo}</div>
                </div>
                ${isUnread ? '<div class="unread-indicator" aria-label="Unread"></div>' : ''}
            </div>
        `;
    }

    // Attach event handlers to notifications
    attachNotificationHandlers() {
        const items = document.querySelectorAll('.notification-item');
        
        items.forEach(item => {
            const handler = (e) => {
                if (e.type === 'click' || e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.handleNotificationClick(item);
                }
            };
            
            // Remove existing handler if any
            const existingHandler = this.clickHandlers.get(item);
            if (existingHandler) {
                item.removeEventListener('click', existingHandler);
                item.removeEventListener('keydown', existingHandler);
            }
            
            // Add new handlers
            item.addEventListener('click', handler);
            item.addEventListener('keydown', handler);
            this.clickHandlers.set(item, handler);
        });
    }

    // Handle notification click
    async handleNotificationClick(item) {
        const notificationId = item.dataset.notificationId;
        const notificationType = item.dataset.notificationType;
        const sessionId = item.dataset.sessionId;

        try {
            await this.markAsRead(notificationId);
            this.navigateToRelevantSection(notificationType, sessionId);
            this.hideDropdown();
        } catch (error) {
            console.error('Error handling notification click:', error);
        }
    }

    // Mark notification as read
    async markAsRead(notificationId) {
        const notification = this.notifications.find(n => n.id === notificationId);
        if (!notification || notification.isRead) return;

        try {
            await db.collection('notifications').doc(notificationId).update({
                isRead: true,
                readAt: new Date(),
                updatedAt: new Date()
            });

            notification.isRead = true;
            this.unreadCount = Math.max(0, this.unreadCount - 1);
            this.updateUI();

        } catch (error) {
            console.error('Failed to mark notification as read:', error);
        }
    }

    // Handle mark all as read
    async handleMarkAllRead() {
        try {
            await this.markAllAsRead();
        } catch (error) {
            console.error('Error marking all as read:', error);
            this.showToast('Failed to mark all notifications as read. Please try again.', 'error');
        }
    }

    // Mark all notifications as read
    async markAllAsRead() {
        const unreadNotifications = this.notifications.filter(n => !n.isRead);
        if (unreadNotifications.length === 0) return;

        try {
            const batch = db.batch();
            const updateTime = new Date();

            unreadNotifications.forEach(notification => {
                const ref = db.collection('notifications').doc(notification.id);
                batch.update(ref, {
                    isRead: true,
                    readAt: updateTime,
                    updatedAt: updateTime
                });
            });

            await batch.commit();

            // Update local state
            this.notifications.forEach(n => { n.isRead = true; });
            this.unreadCount = 0;
            this.updateUI();

            this.showToast('All notifications marked as read', 'success');

        } catch (error) {
            throw new Error(`Failed to mark all as read: ${error.message}`);
        }
    }

    // Handle clear all
    async handleClearAll() {
        try {
            await this.clearAll();
        } catch (error) {
            console.error('Error clearing all notifications:', error);
            this.showToast('Failed to clear notifications. Please try again.', 'error');
        }
    }

    // Clear all notifications
    async clearAll() {
        if (this.notifications.length === 0) return;

        // Confirm action
        if (!confirm('Are you sure you want to clear all notifications? This action cannot be undone.')) {
            return;
        }

        try {
            const batch = db.batch();

            this.notifications.forEach(notification => {
                const ref = db.collection('notifications').doc(notification.id);
                batch.delete(ref);
            });

            await batch.commit();

            // Clear local state
            this.notifications = [];
            this.unreadCount = 0;
            this.updateUI();

            this.showToast('All notifications cleared', 'success');

        } catch (error) {
            throw new Error(`Failed to clear notifications: ${error.message}`);
        }
    }

    // Setup event listeners with proper cleanup
    setupEventListeners() {
        this.removeEventListeners();

        // Notification bell click
        this.notificationBtn = document.querySelector('.notification-btn');
        if (this.notificationBtn) {
            this.notificationBtn.addEventListener('click', this.handleBellClick);
        }

        // Dropdown buttons
        const markAllReadBtn = document.getElementById('markAllReadBtn');
        const clearNotificationsBtn = document.getElementById('clearNotificationsBtn');

        if (markAllReadBtn) {
            markAllReadBtn.addEventListener('click', this.handleMarkAllRead);
        }
        if (clearNotificationsBtn) {
            clearNotificationsBtn.addEventListener('click', this.handleClearAll);
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', this.handleOutsideClick);
        
        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeydown);
    }

    // Handle notification bell click
    handleBellClick(e) {
        e.stopPropagation();
        this.toggleDropdown();
    }

    // Toggle dropdown visibility
    toggleDropdown() {
        const dropdown = document.getElementById('notificationDropdown');
        if (!dropdown) return;

        if (dropdown.classList.contains('visible')) {
            this.hideDropdown();
        } else {
            this.showDropdown();
        }
    }

    // Show dropdown
    showDropdown() {
        const dropdown = document.getElementById('notificationDropdown');
        if (dropdown) {
            dropdown.classList.remove('hidden');
            dropdown.classList.add('visible');
            dropdown.setAttribute('aria-hidden', 'false');
            
            // Focus management for accessibility
            setTimeout(() => {
                const firstItem = dropdown.querySelector('.notification-item');
                if (firstItem) firstItem.focus();
            }, 100);
        }
    }

    // Hide dropdown
    hideDropdown() {
        const dropdown = document.getElementById('notificationDropdown');
        if (dropdown) {
            dropdown.classList.remove('visible');
            dropdown.classList.add('hidden');
            dropdown.setAttribute('aria-hidden', 'true');
        }
    }

    // Handle outside clicks
    handleOutsideClick(e) {
        const dropdown = document.getElementById('notificationDropdown');
        const bell = document.querySelector('.notification-btn');
        
        if (dropdown && bell && !dropdown.contains(e.target) && !bell.contains(e.target)) {
            this.hideDropdown();
        }
    }

    // Handle keyboard navigation
    handleKeydown(e) {
        if (e.key === 'Escape') {
            this.hideDropdown();
        }
    }

    // Start realtime listener with cleanup
    startRealtimeListener() {
        this.cleanupRealtimeListener();

        try {
            this.realtimeListener = db.collection('notifications')
                .where('userId', '==', currentUser.uid)
                .orderBy('createdAt', 'desc')
                .onSnapshot(this.handleRealtimeUpdate, this.handleRealtimeError);
        } catch (error) {
            console.warn('Realtime listener failed to start:', error);
        }
    }

    // Handle realtime updates
    handleRealtimeUpdate(snapshot) {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                this.handleNewNotification(change.doc);
            } else if (change.type === 'modified') {
                this.handleUpdatedNotification(change.doc);
            } else if (change.type === 'removed') {
                this.handleRemovedNotification(change.doc.id);
            }
        });
    }

    // Handle realtime errors gracefully
    handleRealtimeError(error) {
        console.warn('Realtime listener error (non-critical):', error);
        // Don't show error to user - system can work without realtime updates
    }

    // Handle new notification
    handleNewNotification(doc) {
        const newNotification = { id: doc.id, ...doc.data() };
        
        // Check for duplicates
        if (this.notifications.find(n => n.id === newNotification.id)) return;

        this.notifications.unshift(newNotification);
        
        if (!newNotification.isRead) {
            this.unreadCount++;
            this.showToastNotification(newNotification);
        }

        this.debouncedUpdate();
    }

    // Handle updated notification
    handleUpdatedNotification(doc) {
        const updatedNotification = { id: doc.id, ...doc.data() };
        const index = this.notifications.findIndex(n => n.id === updatedNotification.id);
        
        if (index !== -1) {
            const wasUnread = !this.notifications[index].isRead;
            const isUnread = !updatedNotification.isRead;
            
            this.notifications[index] = updatedNotification;
            
            if (wasUnread && !isUnread) {
                this.unreadCount = Math.max(0, this.unreadCount - 1);
            } else if (!wasUnread && isUnread) {
                this.unreadCount++;
            }
            
            this.debouncedUpdate();
        }
    }

    // Handle removed notification
    handleRemovedNotification(notificationId) {
        const notification = this.notifications.find(n => n.id === notificationId);
        if (notification && !notification.isRead) {
            this.unreadCount = Math.max(0, this.unreadCount - 1);
        }
        
        this.notifications = this.notifications.filter(n => n.id !== notificationId);
        this.debouncedUpdate();
    }

    // Debounced UI update
    debouncedUpdate() {
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }
        this.updateTimeout = setTimeout(() => this.updateUI(), 100);
    }

    // Show toast notification
    showToastNotification(notification) {
        const message = this.generateNotificationMessage(notification);
        this.showToast(message, 'info');
    }

    // Show generic toast
    showToast(message, type = 'info') {
        // Simple console log for now - can be enhanced with proper toast UI
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    // Utility methods
    generateNotificationMessage(notification) {
        if (notification.message) return notification.message;
        
        const messages = {
            session_request: 'You have a new session request waiting for confirmation.',
            session_confirmed: 'Your session has been confirmed.',
            session_cancelled: 'A session has been cancelled.',
            payment_processed: 'Your payment has been processed successfully.',
            reschedule_request: 'There is a reschedule request for your session.',
            invoice_submitted: 'Your invoice has been submitted for processing.'
        };
        
        return messages[notification.type] || 'You have a new notification.';
    }

    getTimeAgo(timestamp) {
        if (!timestamp) return 'Recently';
        
        const now = new Date();
        const date = timestamp?.toDate ? timestamp.toDate() : new Date(timestamp);
        if (isNaN(date.getTime())) return 'Recently';
        
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} min ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        
        return date.toLocaleDateString();
    }

    getNotificationIcon(type) {
        const icons = {
            session_request: 'fas fa-calendar-plus',
            session_confirmed: 'fas fa-calendar-check',
            session_cancelled: 'fas fa-calendar-times',
            payment_processed: 'fas fa-dollar-sign',
            reschedule_request: 'fas fa-clock',
            invoice_submitted: 'fas fa-file-invoice'
        };
        return icons[type] || 'fas fa-bell';
    }

    getNotificationColor(type) {
        const colors = {
            session_request: '#ffc107',
            session_confirmed: '#28a745',
            session_cancelled: '#dc3545',
            payment_processed: '#007bff',
            reschedule_request: '#6f42c1',
            invoice_submitted: '#17a2b8'
        };
        return colors[type] || '#6c757d';
    }

    escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // Error handling methods
    handleInitializationError(error) {
        console.error('Notification system initialization failed:', error);
        this.showErrorState('Failed to initialize notifications. Some features may be unavailable.');
    }

    handleLoadError(error) {
        console.error('Failed to load notifications:', error);
        this.showErrorState('Failed to load notifications. Please try again.');
    }

    showErrorState(message) {
        const list = document.getElementById('notificationList');
        if (list) {
            list.innerHTML = `
                <div class="notification-error">
                    <i class="fas fa-exclamation-triangle" aria-hidden="true"></i>
                    <p>${message}</p>
                    <button class="btn-retry" onclick="window.notificationSystem.loadNotifications()">
                        Try Again
                    </button>
                </div>
            `;
        }
    }

    showLoadingState() {
        const list = document.getElementById('notificationList');
        if (list) {
            list.innerHTML = `
                <div class="notification-loading">
                    <div class="loading-spinner" aria-label="Loading notifications"></div>
                    <span>Loading notifications...</span>
                </div>
            `;
        }
    }

    getEmptyStateHTML() {
        return `
            <div class="notification-empty">
                <i class="fas fa-bell-slash" aria-hidden="true"></i>
                <p>No notifications yet</p>
            </div>
        `;
    }

    updateFooter() {
        const footer = document.getElementById('notificationFooterText');
        if (!footer) return;

        const unreadCount = this.notifications.filter(n => !n.isRead).length;
        if (unreadCount > 0) {
            footer.textContent = `${unreadCount} unread notification${unreadCount !== 1 ? 's' : ''}`;
        } else {
            footer.textContent = "You're all caught up!";
        }
    }

    navigateToRelevantSection(type, sessionId) {
        const sectionMap = {
            session_request: 'tutoring-opportunities',
            reschedule_request: 'tutoring-opportunities',
            session_confirmed: 'bookings',
            session_cancelled: 'sessions',
            payment_processed: 'your-earnings',
            invoice_submitted: 'your-earnings'
        };

        const sectionId = sectionMap[type];
        if (sectionId) {
            const menuItem = document.querySelector(`[data-section="${sectionId}"]`);
            if (menuItem) menuItem.click();
        }
    }

    // Cleanup methods
    removeEventListeners() {
        if (this.notificationBtn) {
            this.notificationBtn.removeEventListener('click', this.handleBellClick);
        }
        
        document.removeEventListener('click', this.handleOutsideClick);
        document.removeEventListener('keydown', this.handleKeydown);
        
        this.clickHandlers.forEach((handler, element) => {
            element.removeEventListener('click', handler);
            element.removeEventListener('keydown', handler);
        });
        this.clickHandlers.clear();
    }

    cleanupRealtimeListener() {
        if (this.realtimeListener) {
            this.realtimeListener();
            this.realtimeListener = null;
        }
    }

    async destroy() {
        this.cleanupRealtimeListener();
        this.removeEventListeners();
        
        const dropdown = document.getElementById('notificationDropdown');
        if (dropdown) dropdown.remove();
        
        const styles = document.getElementById('notification-system-styles');
        if (styles) styles.remove();
        
        this.isInitialized = false;
        this.notifications = [];
        this.unreadCount = 0;
    }
}

// Initialize notification system when ready
document.addEventListener('DOMContentLoaded', function() {
    // Create global instance
    window.notificationSystem = new NotificationSystem();

    // Wait for Firebase and user to be ready
    const initNotificationSystem = async () => {
        try {
            if (typeof db !== 'undefined' && currentUser?.uid) {
                await window.notificationSystem.initialize();
            }
        } catch (error) {
            console.error('Failed to initialize notification system:', error);
        }
    };

    // Try immediately
    initNotificationSystem();

    // Fallback: check every 500ms for up to 10 seconds
    let attempts = 0;
    const maxAttempts = 20;
    
    const intervalId = setInterval(() => {
        if (typeof db !== 'undefined' && currentUser?.uid) {
            clearInterval(intervalId);
            initNotificationSystem();
        } else if (attempts++ >= maxAttempts) {
            clearInterval(intervalId);
            console.warn('Notification system: Firebase or user not available after timeout');
        }
    }, 500);
});

// =======================================================================================================================================
// Notification System Ends Here. This is Production ready, and this is the end of the project. Awesome!
// =======================================================================================================================================

// ============================================================================
// PACKAGE STORE FUNCTIONS - ADD THESE AT THE END OF YOUR EXISTING JAVASCRIPT
// ============================================================================

async function purchasePackage(packageType) {
  const purchaseBtn = event.target;
  const originalText = purchaseBtn.innerHTML;
  
  try {
    // Show loading state
    purchaseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
    purchaseBtn.classList.add('btn-loading');
    
    const result = await createPackageCheckout({ 
      studentId: auth.currentUser.uid,
      packageType: packageType
    });
    
    // Redirect to Stripe Checkout
    window.location.href = result.data.url;
    
  } catch (error) {
    console.error('Failed to start package purchase:', error);
    alert('Failed to start purchase. Please try again.');
    
    // Reset button
    purchaseBtn.innerHTML = originalText;
    purchaseBtn.classList.remove('btn-loading');
  }
}

// Load and display package balance
async function loadPackageBalance() {
  try {
    // Check if user is authenticated
    if (!auth.currentUser) {
      console.log('User not authenticated, skipping package balance load');
      return;
    }
    
    const studentDoc = await db.collection('students').doc(auth.currentUser.uid).get();
    
    if (studentDoc.exists) {
      const studentData = studentDoc.data();
      const packageBalances = studentData.packageBalances || {};
      
      // Get balances for each package type
      const taiwoBalance = packageBalances.taiwo || 0;
      const hourlyBalance = packageBalances.hourly || 0;
      const bronzeBalance = packageBalances.bronze || 0;
      const silverBalance = packageBalances.silver || 0;
      const goldBalance = packageBalances.gold || 0;
      
      // Calculate total sessions
      const totalSessions = taiwoBalance + hourlyBalance + bronzeBalance + silverBalance + goldBalance;
      
      // Update the display - you can choose one of these options:
      
      // OPTION 1: Show total sessions (simplest)
      document.getElementById('taiwoBalance').innerHTML = `
        <strong>Total Available Sessions: ${totalSessions}</strong>
        ${taiwoBalance > 0 ? `<br>Taiwo: ${taiwoBalance} session${taiwoBalance !== 1 ? 's' : ''}` : ''}
        ${hourlyBalance > 0 ? `<br>Hourly: ${hourlyBalance} session${hourlyBalance !== 1 ? 's' : ''}` : ''}
        ${bronzeBalance > 0 ? `<br>Bronze: ${bronzeBalance} session${bronzeBalance !== 1 ? 's' : ''}` : ''}
        ${silverBalance > 0 ? `<br>Silver: ${silverBalance} session${silverBalance !== 1 ? 's' : ''}` : ''}
        ${goldBalance > 0 ? `<br>Gold: ${goldBalance} session${goldBalance !== 1 ? 's' : ''}` : ''}
      `;
      
      // OPTION 2: Or if you prefer separate displays, you'd need to add more HTML elements
    }
  } catch (error) {
    console.error('Error loading package balance:', error);
  }
}  
// Check for successful return from Stripe
function checkPurchaseSuccess() {
  const urlParams = new URLSearchParams(window.location.search);
  
if (urlParams.get('success') === 'true') {
    showPurchaseSuccessMessage();
    // Clean URL
    window.history.replaceState({}, '', '/testing/student-dashboard.html');
  }
  
  if (urlParams.get('canceled') === 'true') {
    // Optional: Show canceled message
    window.history.replaceState({}, '', '/testing/student-dashboard.html');
  }
}

function showPurchaseSuccessMessage() {
  // You can use a toast notification or alert
  alert('🎉 Package purchased successfully! Your balance has been updated. You can now book sessions using your package credits.');
  
  // Refresh balance display
  loadPackageBalance();
}

// Load purchase history (optional enhancement)
async function loadPurchaseHistory() {
  try {
    const container = document.getElementById('purchaseHistoryContainer');
    container.innerHTML = '<div class="spinner"></div>';
    
    const purchasesSnapshot = await db.collection('packagePurchases')
      .where('studentId', '==', auth.currentUser.uid)
      .orderBy('purchasedAt', 'desc')
      .get();
    
    if (purchasesSnapshot.empty) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-receipt"></i>
          <h3>No Purchase History</h3>
          <p>Your package purchases will appear here</p>
        </div>
      `;
      return;
    }
    
    let html = '<div class="purchases-list">';
    
    purchasesSnapshot.forEach(doc => {
      const purchase = doc.data();
      const purchaseDate = purchase.purchasedAt?.toDate() || new Date();
      const formattedDate = purchaseDate.toLocaleDateString();
      const formattedTime = purchaseDate.toLocaleTimeString();
      
      // Map package types to display names
      const packageNames = {
        'hourly': 'Hourly Session', 
        'bronze': 'Bronze Package (4 Sessions)',
        'silver': 'Silver Package (8 Sessions)',
        'gold': 'Gold Package (12 Sessions)'
      };
      
      html += `
        <div class="purchase-item">
          <div class="purchase-header">
            <div class="purchase-title">${packageNames[purchase.packageType] || purchase.packageType}</div>
            <div class="purchase-amount">$${purchase.amount}</div>
          </div>
          <div class="purchase-details">
            <div class="purchase-date">
              <i class="fas fa-calendar"></i>
              ${formattedDate} at ${formattedTime}
            </div>
            <div class="purchase-sessions">
              <i class="fas fa-ticket-alt"></i>
              ${purchase.sessions} session${purchase.sessions !== 1 ? 's' : ''}
            </div>
            <div class="purchase-id">
              <i class="fas fa-receipt"></i>
              ${purchase.stripeSessionId || 'No receipt'}
            </div>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
  } catch (error) {
    console.error('Error loading purchase history:', error);
    document.getElementById('purchaseHistoryContainer').innerHTML = `
      <div class="error-state">
        <i class="fas fa-exclamation-circle"></i>
        <h3>Error Loading History</h3>
        <p>Failed to load purchase history. Please try again.</p>
      </div>
    `;
  }
}
  
// Initialize package store when page loads
function initPackageStore() {
  checkPurchaseSuccess();
  loadPackageBalance();
}

// ============================================================================
// END PACKAGE STORE FUNCTIONS
// ============================================================================  

// =======================================================
// STUDENT CHAT SYSTEM WITH AUTO-CREATION STARTS HERE
// =======================================================

// =======================================================
// CHAT SYSTEM IMPLEMENTATION
// =======================================================

// Global chat variables with initialization tracking
let currentChat = null;
let chatMessagesListener = null;
let contactsListener = null;
let typingTimeout = null;
let chatSystemInitialized = false;
let chatListenersActive = false;

// Initialize chat system
function initChatSystem() {
    if (chatSystemInitialized) {
        console.log('Chat system already initialized');
        return;
    }
    
    console.log('Initializing chat system...');
    chatSystemInitialized = true;
    
    setupChatEventListeners();
    loadChatContacts();
    setupRealtimeListeners();
}

// Setup chat event listeners
function setupChatEventListeners() {
    // Send message on button click
    const sendBtn = document.getElementById('sendMessageBtn');
    if (sendBtn) {
        sendBtn.addEventListener('click', sendMessage);
    }
    
    // Send message on Enter key (but allow Shift+Enter for new line)
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Auto-resize textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    }
    
    // Contact search
    const contactSearch = document.getElementById('contactSearch');
    if (contactSearch) {
        contactSearch.addEventListener('input', function(e) {
            filterContacts(e.target.value);
        });
    }
}

// Load chat contacts
// Load chat contacts with permanent admin option
function loadChatContacts() {
    const contactsList = document.getElementById('contactsList');
    if (!contactsList) return;
    
    // Clean up previous listener
    if (contactsListener) {
        contactsListener();
    }
    
    contactsList.innerHTML = '<div class="loading-state">Loading conversations...</div>';

    // Create permanent admin support contact
    const createAdminContact = () => {
        const adminContact = document.createElement('div');
        adminContact.className = 'contact-item admin-contact';
        adminContact.setAttribute('data-contact-id', 'admin');
        adminContact.setAttribute('data-tutor-id', 'admin');
        adminContact.innerHTML = `
            <div class="contact-avatar" style="background: linear-gradient(135deg, #ff6b6b, #ee5a52);">
                <i class="fas fa-headset"></i>
            </div>
            <div class="contact-info">
                <div class="contact-name">Customer Support</div>
                <div class="contact-subject">TKLesson Support Team</div>
                <div class="contact-status">
                    <div class="status-online"></div>
                    <div class="last-message">Available 24/7 for assistance</div>
                </div>
            </div>
            <div class="contact-status">
                <div class="status-badge admin-badge">Support</div>
            </div>
        `;
        
        adminContact.addEventListener('click', () => {
            // Create admin contact object for openChat function
            const adminContactInfo = {
                chatId: `support_student_${auth.currentUser.uid}`,
                tutorId: 'admin',
                tutorName: 'Customer Support',
                tutorSubjects: ['Support & Assistance'],
                lastMessage: 'Click to start conversation',
                lastMessageAt: new Date(),
                unreadCount: 0,
                isAdmin: true
            };
            openChat(adminContactInfo);
        });
        
        // Add admin contact to the top of the list permanently
        if (contactsList.firstChild && contactsList.firstChild.className !== 'loading-state') {
            contactsList.insertBefore(adminContact, contactsList.firstChild);
        } else {
            contactsList.appendChild(adminContact);
        }
    };

    const studentId = auth.currentUser.uid;
    
    contactsListener = db.collection('chats')
        .where('participants', 'array-contains', studentId)
        .orderBy('lastMessageAt', 'desc')
        .onSnapshot(async (snapshot) => {
            contactsList.innerHTML = '';
            
            // Always add admin contact first
            createAdminContact();
            
            if (snapshot.empty) {
                contactsList.innerHTML += `
                    <div class="empty-state">
                        <i class="fas fa-comments"></i>
                        <h4>No Tutor Conversations</h4>
                        <p>Start a conversation with your tutors from the Tutors section</p>
                    </div>
                `;
                updateUnreadMessagesCount(0);
                return;
            }
            
            const contacts = [];
            let totalUnread = 0;
            
            for (const doc of snapshot.docs) {
                const chat = doc.data();
                const otherParticipantId = chat.participants.find(id => id !== studentId);
                
                // Skip admin chats in the main list (they're handled separately)
                if (otherParticipantId === 'support') continue;
                
                if (otherParticipantId) {
                    try {
                        // Get tutor details
                        const tutorDoc = await db.collection('tutors').doc(otherParticipantId).get();
                        if (tutorDoc.exists) {
                            const tutor = tutorDoc.data();
                            const unreadCount = chat.unreadCounts?.[studentId] || 0;
                            totalUnread += unreadCount;
                            
                            const contact = {
                                chatId: doc.id,
                                tutorId: otherParticipantId,
                                tutorName: tutor.personal?.fullName || 'Tutor',
                                tutorSubjects: tutor.subjects?.subjects || [],
                                tutorAvatar: tutor.photoURL,
                                lastMessage: chat.lastMessage,
                                lastMessageAt: chat.lastMessageAt,
                                unreadCount: unreadCount,
                                isAdmin: false
                            };
                            contacts.push(contact);
                            
                            const contactElement = createContactElement(contact);
                            contactsList.appendChild(contactElement);
                        }
                    } catch (error) {
                        console.error('Error loading tutor details:', error);
                    }
                }
            }
            
            updateUnreadMessagesCount(totalUnread);
        }, (error) => {
            console.error('Error loading contacts:', error);
            contactsList.innerHTML = '<div class="error-state">Error loading conversations</div>';
        });
}
  
// Clean up chat system properly
function cleanupChatSystem() {
    if (contactsListener) {
        contactsListener();
        contactsListener = null;
    }
    
    if (chatMessagesListener) {
        chatMessagesListener();
        chatMessagesListener = null;
    }
    
    currentChat = null;
    chatSystemInitialized = false;
    chatListenersActive = false;
    
    console.log('Chat system cleaned up');
}
  
// Create contact element
function createContactElement(contact) {
    const contactDiv = document.createElement('div');
    contactDiv.className = `contact-item ${currentChat?.tutorId === contact.tutorId ? 'active' : ''}`;
    contactDiv.setAttribute('data-tutor-id', contact.tutorId);
    contactDiv.setAttribute('data-chat-id', contact.chatId);
    
    const lastMessageTime = contact.lastMessageAt ? formatMessageTime(contact.lastMessageAt.toDate()) : '';
    const unreadBadge = contact.unreadCount > 0 ? 
        `<div class="unread-count">${contact.unreadCount}</div>` : '';
    
    contactDiv.innerHTML = `
        <div class="contact-avatar">
            ${contact.tutorAvatar ? 
                `<img src="${contact.tutorAvatar}" alt="${contact.tutorName}">` : 
                `<i class="fas fa-user-tie"></i>`
            }
        </div>
        <div class="contact-info">
            <div class="contact-name">${contact.tutorName}</div>
            <div class="contact-subject">${contact.tutorSubjects.join(', ') || 'No subjects listed'}</div>
            <div class="last-message">${contact.lastMessage || 'No messages yet'}</div>
        </div>
        <div class="contact-status">
            <div class="status-online"></div>
            ${unreadBadge}
            <div class="last-message-time">${lastMessageTime}</div>
        </div>
    `;
    
    contactDiv.addEventListener('click', () => openChat(contact));
    
    return contactDiv;
}

// Open chat with tutor
async function openChat(contact) {
    try {
        currentChat = contact;
        
        // Update UI to show chat is active
        document.querySelectorAll('.contact-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Update active contact in list - handle both tutor and admin contacts
        const activeContact = document.querySelector(`[data-tutor-id="${contact.tutorId}"]`);
        if (activeContact) {
            activeContact.classList.add('active');
        }
        
        // Show chat interface
        document.getElementById('emptyChatState').style.display = 'none';
        document.getElementById('chatHeader').style.display = 'flex';
        document.getElementById('messagesContainer').style.display = 'flex';
        document.getElementById('messageInputContainer').style.display = 'block';
        
        // Update header based on contact type
        document.getElementById('currentContactName').textContent = contact.tutorName;
        document.getElementById('currentContactSubject').textContent = 
            contact.tutorSubjects.join(', ') || (contact.isAdmin ? 'TKLesson Support' : 'General');
        
        // Update avatar and UI based on contact type
        const avatar = document.querySelector('#chatHeader .contact-avatar');
        const chatActions = document.querySelector('.chat-actions');
        
        if (contact.isAdmin) {
            // Admin chat styling
            avatar.innerHTML = '<i class="fas fa-headset"></i>';
            avatar.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a52)';
            
            // Hide schedule session button for admin
            if (chatActions) {
                chatActions.style.display = 'none';
            }
            
            // Add admin-specific quick messages
            setupAdminQuickMessages();
            
            // For admin chats, check if chat exists and show welcome if not
            await handleAdminChatWelcome(contact.chatId);
        } else {
            // Tutor chat styling
            avatar.innerHTML = contact.tutorAvatar ? 
                `<img src="${contact.tutorAvatar}" alt="${contact.tutorName}">` : 
                '<i class="fas fa-user-tie"></i>';
            avatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
            
            // Show schedule session button for tutors
            if (chatActions) {
                chatActions.style.display = 'flex';
            }
            
            // Setup tutor quick messages
            setupTutorQuickMessages();
            
            // Load messages normally for tutors
            loadChatMessages(contact.chatId);
        }
        
        // Mark as read if it's a real chat (not admin placeholder)
        if (contact.chatId && !contact.isAdmin) {
            await markChatAsRead(contact.chatId);
        }
        
    } catch (error) {
        console.error('Error opening chat:', error);
    }
}

// Handle admin chat welcome message
async function handleAdminChatWelcome(chatId) {
    const messagesContainer = document.getElementById('messagesContainer');
    if (!messagesContainer) return;
    
    // Check if admin chat exists
    const adminChatRef = db.collection('chats').doc(chatId);
    const chatDoc = await adminChatRef.get();
    
    if (!chatDoc.exists) {
        // No admin chat exists yet - show welcome message
        messagesContainer.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-headset" style="font-size: 3rem; color: #ff6b6b; margin-bottom: 1rem;"></i>
                <h4>Welcome to Customer Support!</h4>
                <p>We're here to help you find the perfect tutor and answer any questions.</p>
                <p><strong>How can we help you today?</strong></p>
                <div class="quick-messages" style="margin-top: 1rem;">
                    <div class="quick-message" onclick="insertQuickMessage('Hello, I need help finding a tutor for my subject')">Help finding a tutor</div>
                    <div class="quick-message" onclick="insertQuickMessage('I have questions about scheduling sessions')">Scheduling questions</div>
                    <div class="quick-message" onclick="insertQuickMessage('Can you help me with payment or account issues?')">Payment/Account help</div>
                </div>
            </div>
        `;
    } else {
        // Admin chat exists - load messages normally
        loadChatMessages(chatId);
    }
}  
// Load chat messages
function loadChatMessages(chatId) {
    const messagesContainer = document.getElementById('messagesContainer');
    if (!messagesContainer) return;
    
    messagesContainer.innerHTML = '<div class="loading-state">Loading messages...</div>';
    
    // Clean up previous listener
    if (chatMessagesListener) {
        chatMessagesListener();
    }
    
    chatMessagesListener = db.collection('chats')
        .doc(chatId)
        .collection('messages')
        .orderBy('timestamp', 'asc')
        .onSnapshot((snapshot) => {
            if (snapshot.empty) {
                messagesContainer.innerHTML = '<div class="empty-state">No messages yet. Start the conversation!</div>';
                return;
            }
            
            messagesContainer.innerHTML = '';
            snapshot.forEach(doc => {
                const message = doc.data();
                const messageElement = createMessageElement(message);
                messagesContainer.appendChild(messageElement);
            });
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });
}

// Create message element - YOUR EXISTING FUNCTION (no changes needed)
function createMessageElement(message) {
    const messageDiv = document.createElement('div');
    const isSent = message.senderId === auth.currentUser.uid;
    
    messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
    messageDiv.innerHTML = `
        <div class="message-text">${message.text}</div>
        <div class="message-time">${formatMessageTime(message.timestamp?.toDate())}</div>
    `;
    
    return messageDiv;
}
  
// Send message
async function sendMessage() {
    const messageInput = document.getElementById('messageInput');
    const messageText = messageInput.value.trim();
    
    if (!messageText || !currentChat) return;
    
    try {
        const studentId = auth.currentUser.uid;
        const studentName = userData?.name || 'Student';
        
        // Check if this is an admin chat
        const isAdminChat = currentChat.isAdmin;
        
        let chatId;
        let receiverId;
        
        if (isAdminChat) {
            // Admin chat - use consistent naming
            chatId = `support_student_${studentId}`;
            receiverId = 'admin';
        } else {
            // Tutor chat - use existing logic
            chatId = currentChat.chatId;
            receiverId = currentChat.tutorId;
        }
        
        const messageData = {
            text: messageText,
            senderId: studentId,
            senderName: studentName,
            timestamp: new Date(),
            read: false,
            type: 'text'
        };
        
        // Get chat reference
        const chatRef = db.collection('chats').doc(chatId);
        const chatDoc = await chatRef.get();
        
        // Create chat if it doesn't exist
        if (!chatDoc.exists) {
            let chatData = {
                participants: [studentId, receiverId],
                participantNames: {
                    [studentId]: studentName,
                    [receiverId]: isAdminChat ? 'Customer Support' : 'Tutor'
                },
                status: 'active',
                lastMessage: messageText,
                lastMessageAt: new Date(),
                lastMessageBy: studentId,
                unreadCounts: {
                    [studentId]: 0,
                    [receiverId]: 1
                },
                createdAt: new Date(),
                lastUpdated: new Date()
            };
            
            // Add admin-specific fields
            if (isAdminChat) {
                chatData.chatType = 'support_student';
                chatData.subject = 'Customer Support';
                chatData.isAdminChat = true;
                chatData.studentId = studentId;
                chatData.studentName = studentName;
            } else {
                chatData.chatType = 'tutor_session';
                chatData.subject = 'Tutoring Session';
            }
            
            await chatRef.set(chatData);
        } else {
            // Update existing chat
            const updateData = {
                lastMessage: messageText,
                lastMessageAt: new Date(),
                lastMessageBy: studentId,
                lastUpdated: new Date()
            };
            
            // Only increment unread count for the receiver
            if (chatDoc.data().lastMessageBy !== studentId) {
                updateData[`unreadCounts.${receiverId}`] = firebase.firestore.FieldValue.increment(1);
            }
            
            await chatRef.update(updateData);
        }
        
        // Add message to messages subcollection
        await chatRef.collection('messages').add(messageData);
        
        // Clear input
        messageInput.value = '';
        messageInput.style.height = 'auto';
        
        // Reload messages to show the new message
        loadChatMessages(chatId);
        
    } catch (error) {
        console.error('Error sending message:', error);
        alert('Failed to send message. Please try again.');
    }
}        

// Setup admin-specific quick messages
function setupAdminQuickMessages() {
    const quickMessagesContainer = document.getElementById('quickMessages');
    if (!quickMessagesContainer) return;
    
    quickMessagesContainer.innerHTML = `
        <div class="quick-message" onclick="insertQuickMessage('Hello, I need help finding a tutor for my subject')">Help finding a tutor</div>
        <div class="quick-message" onclick="insertQuickMessage('I\\'m having trouble with scheduling sessions')">Scheduling issue</div>
        <div class="quick-message" onclick="insertQuickMessage('Can you help me with payment questions?')">Payment question</div>
        <div class="quick-message" onclick="insertQuickMessage('I need technical support with the platform')">Technical support</div>
    `;
    quickMessagesContainer.style.display = 'flex';
}

// Setup tutor-specific quick messages
function setupTutorQuickMessages() {
    const quickMessagesContainer = document.getElementById('quickMessages');
    if (!quickMessagesContainer) return;
    
    quickMessagesContainer.innerHTML = `
        <div class="quick-message" onclick="insertQuickMessage('Hello, I have a question about our session')">Question about session</div>
        <div class="quick-message" onclick="insertQuickMessage('Can we reschedule our lesson?')">Reschedule request</div>
        <div class="quick-message" onclick="insertQuickMessage('I need help with the subject material')">Need subject help</div>
        <div class="quick-message" onclick="insertQuickMessage('Thank you for the help!')">Say thanks</div>
    `;
    quickMessagesContainer.style.display = 'flex';
}
  
// Utility functions
function formatMessageTime(date) {
    if (!date) return '';
    
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    
    return date.toLocaleDateString();
}

// Mark chat as read
async function markChatAsRead(chatId) {
    try {
        await db.collection('chats')
            .doc(chatId)
            .update({
                [`unreadCounts.${auth.currentUser.uid}`]: 0
            });
    } catch (error) {
        console.error('Error marking chat as read:', error);
    }
}

// Insert quick message
function insertQuickMessage(text) {
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.value = text;
        messageInput.focus();
    }
}

// Schedule session with current tutor
function scheduleSessionWithTutor() {
    if (!currentChat) return;
    
    // Switch to scheduling section and pre-select the tutor
    document.querySelectorAll('.menu-item a').forEach(a => a.classList.remove('active'));
    document.querySelectorAll('.dashboard-section').forEach(section => section.classList.remove('active'));
    
    const schedulingLink = document.querySelector('a[data-section="scheduling"]');
    const schedulingSection = document.getElementById('scheduling');
    
    if (schedulingLink && schedulingSection) {
        schedulingLink.classList.add('active');
        schedulingSection.classList.add('active');
        
        // Pre-select the tutor
        setTimeout(() => {
            const tutorSelect = document.getElementById('tutor');
            if (tutorSelect) {
                tutorSelect.value = currentChat.tutorId;
                const event = new Event('change');
                tutorSelect.dispatchEvent(event);
            }
        }, 100);
    }
}

// Filter contacts
function filterContacts(searchTerm) {
    const contactItems = document.querySelectorAll('.contact-item');
    contactItems.forEach(item => {
        const tutorName = item.querySelector('.contact-name').textContent.toLowerCase();
        const tutorSubject = item.querySelector('.contact-subject').textContent.toLowerCase();
        const searchLower = searchTerm.toLowerCase();
        
        if (tutorName.includes(searchLower) || tutorSubject.includes(searchLower)) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
    });
}

// Update unread messages count in menu
function updateUnreadMessagesCount(count) {
    const unreadBadge = document.getElementById('unreadMessagesCount');
    if (unreadBadge) {
        if (count > 0) {
            unreadBadge.textContent = count > 99 ? '99+' : count.toString();
            unreadBadge.style.display = 'inline';
        } else {
            unreadBadge.style.display = 'none';
        }
    }
}

// Setup realtime listeners
function setupRealtimeListeners() {
    console.log('Setting up realtime chat listeners...');
    // Additional real-time features can be added here
}

// Start new chat with tutor (called from tutors list)
async function startNewChat(tutorId) {
    try {
        // Show loading state
        const contactsList = document.getElementById('contactsList');
        if (contactsList) {
            contactsList.innerHTML = '<div class="loading-state">Starting conversation...</div>';
        }
        
        // Create or get chat
        const chat = await getOrCreateChat(tutorId);
        
        // Open the chat
        const contact = {
            chatId: chat.id,
            tutorId: tutorId,
            tutorName: chat.participantNames[tutorId] || 'Tutor',
            tutorSubjects: [], // We'll load this separately
            lastMessage: chat.lastMessage,
            lastMessageAt: chat.lastMessageAt,
            unreadCount: chat.unreadCounts[auth.currentUser.uid] || 0
        };
        
        // Load tutor subjects
        try {
            const tutorDoc = await db.collection('tutors').doc(tutorId).get();
            if (tutorDoc.exists) {
                const tutor = tutorDoc.data();
                contact.tutorSubjects = tutor.subjects?.subjects || [];
                contact.tutorAvatar = tutor.photoURL;
            }
        } catch (error) {
            console.warn('Could not load tutor details:', error);
        }
        
        await openChat(contact);
        
    } catch (error) {
        console.error('Error starting new chat:', error);
        alert('Failed to start chat. Please try again.');
    }
}

// Create or get chat between student and tutor
async function getOrCreateChat(tutorId) {
    const studentId = auth.currentUser.uid;
    const chatId = [studentId, tutorId].sort().join('_');
    
    try {
        // Check if chat already exists
        const existingChat = await db.collection('chats').doc(chatId).get();
        
        if (existingChat.exists) {
            console.log('Found existing chat:', chatId);
            return { id: chatId, ...existingChat.data() };
        }
        
        // Create new chat
        console.log('Creating new chat between student and tutor...');
        
        // Get user names
        const [studentDoc, tutorDoc] = await Promise.all([
            db.collection('students').doc(studentId).get(),
            db.collection('tutors').doc(tutorId).get()
        ]);
        
        const studentName = studentDoc.data()?.name || studentDoc.data()?.fullName || 'Student';
        const tutorName = tutorDoc.data()?.personal?.fullName || tutorDoc.data()?.fullName || 'Tutor';
        
        const chatData = {
            participants: [studentId, tutorId],
            participantNames: {
                [studentId]: studentName,
                [tutorId]: tutorName
            },
            lastMessage: '',
            lastMessageAt: new Date(),
            createdAt: new Date(),
            unreadCounts: {
                [studentId]: 0,
                [tutorId]: 0
            },
            typing: {
                [studentId]: false,
                [tutorId]: false
            },
            status: 'active'
        };
        
        await db.collection('chats').doc(chatId).set(chatData);
        console.log('Created new chat:', chatId);
        
        return { id: chatId, ...chatData };
        
    } catch (error) {
        console.error('Error creating/getting chat:', error);
        throw error;
    }
}
  
// Initialize chat system when dashboard loads
function initializeChatOnAuth() {
    if (auth.currentUser) {
        setTimeout(() => {
            initChatSystem();
        }, 2000);
    }
}

// Add chat initialization to your existing auth state listener
// In your existing auth.onAuthStateChanged, add:
auth.onAuthStateChanged((user) => {
    if (user) {
        currentUser = user;
        // ... your existing code ...
        
        // Initialize chat system
        initializeChatOnAuth();
    }
});

// One-time function to clean up duplicate chats
async function cleanupDuplicateChats() {
    const studentId = auth.currentUser.uid;
    
    try {
        // Get all chats for this student
        const chatsSnapshot = await db.collection('chats')
            .where('participants', 'array-contains', studentId)
            .get();
        
        const chatGroups = {};
        
        // Group chats by tutor-student pair
        chatsSnapshot.forEach(doc => {
            const chat = doc.data();
            const tutorId = chat.participants.find(id => id !== studentId);
            
            if (tutorId) {
                const chatKey = [studentId, tutorId].sort().join('_');
                
                if (!chatGroups[chatKey]) {
                    chatGroups[chatKey] = [];
                }
                chatGroups[chatKey].push({ id: doc.id, ...chat });
            }
        });
        
        // For each group with multiple chats, keep the newest and delete others
        const cleanupPromises = [];
        
        Object.entries(chatGroups).forEach(([chatKey, chats]) => {
            if (chats.length > 1) {
                // Sort by creation date (newest first)
                chats.sort((a, b) => {
                    const aTime = a.createdAt?.toDate()?.getTime() || 0;
                    const bTime = b.createdAt?.toDate()?.getTime() || 0;
                    return bTime - aTime;
                });
                
                // Keep the newest chat, delete others
                const chatsToDelete = chats.slice(1);
                
                chatsToDelete.forEach(chat => {
                    console.log(`Deleting duplicate chat: ${chat.id}`);
                    cleanupPromises.push(db.collection('chats').doc(chat.id).delete());
                });
            }
        });
        
        await Promise.all(cleanupPromises);
        console.log('Duplicate chat cleanup completed');
        
    } catch (error) {
        console.error('Error cleaning up duplicate chats:', error);
    }
}
  
// =======================================================
// MOBILE CHAT FUNCTIONALITY FOR STUDENT DASHBOARD
// =======================================================

// Mobile chat state
let isMobileChatOpen = false;

// Setup mobile back button
function setupMobileChatFeatures() {
    const chatBackBtn = document.getElementById('chatBackBtn');
    
    if (chatBackBtn) {
        chatBackBtn.addEventListener('click', function() {
            // Show contacts list, hide chat messages
            document.querySelector('.chat-contacts').style.display = 'block';
            document.querySelector('.chat-messages').style.display = 'none';
            document.getElementById('mobileChatHeader').style.display = 'none';
            
            // Reset mobile state
            isMobileChatOpen = false;
            
            // Remove active class from all contacts
            document.querySelectorAll('.contact-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Reset current chat
            currentChat = null;
        });
    }
}

// Enhanced openChat function with mobile support
const originalOpenChat = window.openChat;
window.openChat = async function(contact) {
    // Mobile behavior
    if (window.innerWidth <= 768) {
        // Hide contacts, show messages
        document.querySelector('.chat-contacts').style.display = 'none';
        document.querySelector('.chat-messages').style.display = 'flex';
        document.getElementById('mobileChatHeader').style.display = 'flex';
        
        isMobileChatOpen = true;
    }
    
    // Call original function
    await originalOpenChat(contact);
};

// Handle window resize for responsive behavior
function setupChatResponsiveBehavior() {
    window.addEventListener('resize', function() {
        // Reset to desktop view on larger screens
        if (window.innerWidth > 768) {
            document.querySelector('.chat-contacts').style.display = 'block';
            document.querySelector('.chat-messages').style.display = 'flex';
            document.getElementById('mobileChatHeader').style.display = 'none';
            isMobileChatOpen = false;
        } else if (window.innerWidth <= 768 && !isMobileChatOpen) {
            // Ensure contacts are visible when not in chat on mobile
            document.querySelector('.chat-contacts').style.display = 'block';
            document.querySelector('.chat-messages').style.display = 'none';
            document.getElementById('mobileChatHeader').style.display = 'none';
        }
    });
}

// Initialize mobile features when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    setupMobileChatFeatures();
    setupChatResponsiveBehavior();
});

// =======================================================
// ENHANCED UNREAD MESSAGE TRACKING
// =======================================================

// Global variables for enhanced unread tracking
let unreadMessagesCount = 0;
let chatUnreadCounts = {}; // { chatId: unreadCount }

// Enhanced loadChatContacts with better unread tracking
function loadChatContacts() {
    const contactsList = document.getElementById('contactsList');
    if (!contactsList) return;
    
    // Clean up previous listener
    if (contactsListener) {
        contactsListener();
    }
    
    contactsList.innerHTML = '<div class="loading-state">Loading conversations...</div>';

    // Create permanent admin support contact
    const createAdminContact = () => {
        const adminContact = document.createElement('div');
        adminContact.className = 'contact-item admin-contact';
        adminContact.setAttribute('data-contact-id', 'admin');
        adminContact.setAttribute('data-tutor-id', 'admin');
        adminContact.innerHTML = `
            <div class="contact-avatar" style="background: linear-gradient(135deg, #ff6b6b, #ee5a52);">
                <i class="fas fa-headset"></i>
            </div>
            <div class="contact-info">
                <div class="contact-name">Customer Support</div>
                <div class="contact-subject">TKLesson Support Team</div>
                <div class="contact-status">
                    <div class="status-online"></div>
                    <div class="last-message">Available 24/7 for assistance</div>
                </div>
            </div>
            <div class="contact-status">
                <div class="status-badge admin-badge">Support</div>
            </div>
        `;
        
        adminContact.addEventListener('click', () => {
            const adminContactInfo = {
                chatId: `support_student_${auth.currentUser.uid}`,
                tutorId: 'admin',
                tutorName: 'Customer Support',
                tutorSubjects: ['Support & Assistance'],
                lastMessage: 'Click to start conversation',
                lastMessageAt: new Date(),
                unreadCount: chatUnreadCounts[`support_student_${auth.currentUser.uid}`] || 0,
                isAdmin: true
            };
            openChat(adminContactInfo);
        });
        
        if (contactsList.firstChild && contactsList.firstChild.className !== 'loading-state') {
            contactsList.insertBefore(adminContact, contactsList.firstChild);
        } else {
            contactsList.appendChild(adminContact);
        }
    };

    const studentId = auth.currentUser.uid;
    
    contactsListener = db.collection('chats')
        .where('participants', 'array-contains', studentId)
        .orderBy('lastMessageAt', 'desc')
        .onSnapshot(async (snapshot) => {
            contactsList.innerHTML = '';
            
            // Always add admin contact first
            createAdminContact();
            
            if (snapshot.empty) {
                contactsList.innerHTML += `
                    <div class="empty-state">
                        <i class="fas fa-comments"></i>
                        <h4>No Tutor Conversations</h4>
                        <p>Start a conversation with your tutors from the Tutors section</p>
                    </div>
                `;
                updateUnreadMessagesCount(0);
                return;
            }
            
            const contacts = [];
            let totalUnread = 0;
            chatUnreadCounts = {}; // Reset unread counts
            
            for (const doc of snapshot.docs) {
                const chat = doc.data();
                const otherParticipantId = chat.participants.find(id => id !== studentId);
                
                // Skip admin chats in the main list (they're handled separately)
                if (otherParticipantId === 'support') continue;
                
                if (otherParticipantId) {
                    try {
                        // Get tutor details
                        const tutorDoc = await db.collection('tutors').doc(otherParticipantId).get();
                        if (tutorDoc.exists) {
                            const tutor = tutorDoc.data();
                            const unreadCount = chat.unreadCounts?.[studentId] || 0;
                            
                            // Store individual chat unread count
                            chatUnreadCounts[doc.id] = unreadCount;
                            totalUnread += unreadCount;
                            
                            const contact = {
                                chatId: doc.id,
                                tutorId: otherParticipantId,
                                tutorName: tutor.personal?.fullName || 'Tutor',
                                tutorSubjects: tutor.subjects?.subjects || [],
                                tutorAvatar: tutor.photoURL,
                                lastMessage: chat.lastMessage,
                                lastMessageAt: chat.lastMessageAt,
                                unreadCount: unreadCount,
                                isAdmin: false
                            };
                            contacts.push(contact);
                            
                            const contactElement = createContactElement(contact);
                            contactsList.appendChild(contactElement);
                        }
                    } catch (error) {
                        console.error('Error loading tutor details:', error);
                    }
                }
            }
            
            // Also check admin chat for unread messages
            await checkAdminChatUnreadCount(studentId, totalUnread);
            
        }, (error) => {
            console.error('Error loading contacts:', error);
            contactsList.innerHTML = '<div class="error-state">Error loading conversations</div>';
        });
}

// Check admin chat for unread messages
async function checkAdminChatUnreadCount(studentId, currentTotalUnread) {
    try {
        const adminChatId = `support_student_${studentId}`;
        const adminChatDoc = await db.collection('chats').doc(adminChatId).get();
        
        if (adminChatDoc.exists) {
            const adminChat = adminChatDoc.data();
            const adminUnreadCount = adminChat.unreadCounts?.[studentId] || 0;
            
            // Store admin chat unread count
            chatUnreadCounts[adminChatId] = adminUnreadCount;
            
            // Update total (admin unread count wasn't included in the main loop)
            const totalUnread = currentTotalUnread + adminUnreadCount;
            unreadMessagesCount = totalUnread;
            
            updateUnreadMessagesCount(totalUnread);
            
            // Update admin contact badge if it exists
            updateAdminContactBadge(adminUnreadCount);
        } else {
            // No admin chat exists yet
            unreadMessagesCount = currentTotalUnread;
            updateUnreadMessagesCount(currentTotalUnread);
        }
    } catch (error) {
        console.error('Error checking admin chat unread count:', error);
        unreadMessagesCount = currentTotalUnread;
        updateUnreadMessagesCount(currentTotalUnread);
    }
}

// Update admin contact badge
function updateAdminContactBadge(unreadCount) {
    const adminContact = document.querySelector('.admin-contact');
    if (!adminContact) return;
    
    // Remove existing unread badge
    const existingBadge = adminContact.querySelector('.unread-count');
    if (existingBadge) {
        existingBadge.remove();
    }
    
    // Add new unread badge if there are unread messages
    if (unreadCount > 0) {
        const contactStatus = adminContact.querySelector('.contact-status');
        if (contactStatus) {
            const unreadBadge = document.createElement('div');
            unreadBadge.className = 'unread-count';
            unreadBadge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
            contactStatus.appendChild(unreadBadge);
        }
    }
}

// Enhanced createContactElement with better unread display
function createContactElement(contact) {
    const contactDiv = document.createElement('div');
    contactDiv.className = `contact-item ${currentChat?.tutorId === contact.tutorId ? 'active' : ''}`;
    contactDiv.setAttribute('data-tutor-id', contact.tutorId);
    contactDiv.setAttribute('data-chat-id', contact.chatId);
    
    const lastMessageTime = contact.lastMessageAt ? formatMessageTime(contact.lastMessageAt.toDate()) : '';
    const unreadBadge = contact.unreadCount > 0 ? 
        `<div class="unread-count">${contact.unreadCount > 99 ? '99+' : contact.unreadCount}</div>` : '';
    
    contactDiv.innerHTML = `
        <div class="contact-avatar">
            ${contact.tutorAvatar ? 
                `<img src="${contact.tutorAvatar}" alt="${contact.tutorName}">` : 
                `<i class="fas fa-user-tie"></i>`
            }
        </div>
        <div class="contact-info">
            <div class="contact-name">${contact.tutorName}</div>
            <div class="contact-subject">${contact.tutorSubjects.join(', ') || 'No subjects listed'}</div>
            <div class="last-message">${contact.lastMessage || 'No messages yet'}</div>
        </div>
        <div class="contact-status">
            <div class="status-online"></div>
            ${unreadBadge}
            <div class="last-message-time">${lastMessageTime}</div>
        </div>
    `;
    
    contactDiv.addEventListener('click', () => openChat(contact));
    
    return contactDiv;
}

// Enhanced openChat with immediate unread count reset
async function openChat(contact) {
    try {
        currentChat = contact;
        
        // Update UI to show chat is active
        document.querySelectorAll('.contact-item').forEach(item => {
            item.classList.remove('active');
        });
        
        const activeContact = document.querySelector(`[data-tutor-id="${contact.tutorId}"]`);
        if (activeContact) {
            activeContact.classList.add('active');
        }
        
        // Show chat interface
        document.getElementById('emptyChatState').style.display = 'none';
        document.getElementById('chatHeader').style.display = 'flex';
        document.getElementById('messagesContainer').style.display = 'flex';
        document.getElementById('messageInputContainer').style.display = 'block';
        
        // Update header
        document.getElementById('currentContactName').textContent = contact.tutorName;
        document.getElementById('currentContactSubject').textContent = 
            contact.tutorSubjects.join(', ') || (contact.isAdmin ? 'TKLesson Support' : 'General');
        
        // Update avatar and UI
        const avatar = document.querySelector('#chatHeader .contact-avatar');
        const chatActions = document.querySelector('.chat-actions');
        
        if (contact.isAdmin) {
            avatar.innerHTML = '<i class="fas fa-headset"></i>';
            avatar.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a52)';
            
            if (chatActions) {
                chatActions.style.display = 'none';
            }
            
            setupAdminQuickMessages();
            await handleAdminChatWelcome(contact.chatId);
        } else {
            avatar.innerHTML = contact.tutorAvatar ? 
                `<img src="${contact.tutorAvatar}" alt="${contact.tutorName}">` : 
                '<i class="fas fa-user-tie"></i>';
            avatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
            
            if (chatActions) {
                chatActions.style.display = 'flex';
            }
            
            setupTutorQuickMessages();
            loadChatMessages(contact.chatId);
        }
        
        // Immediately mark as read and update counts
        if (contact.chatId) {
            await markChatAsRead(contact.chatId);
            updateContactUnreadCount(contact.chatId, 0);
        }
        
    } catch (error) {
        console.error('Error opening chat:', error);
    }
}

// Enhanced markChatAsRead with better count management
async function markChatAsRead(chatId) {
    try {
        const studentId = auth.currentUser.uid;
        
        // Update in Firestore
        await db.collection('chats')
            .doc(chatId)
            .update({
                [`unreadCounts.${studentId}`]: 0
            });
        
        // Update local state immediately
        const oldUnreadCount = chatUnreadCounts[chatId] || 0;
        chatUnreadCounts[chatId] = 0;
        
        // Update total unread count
        unreadMessagesCount = Math.max(0, unreadMessagesCount - oldUnreadCount);
        updateUnreadMessagesCount(unreadMessagesCount);
        
        // Update contact badge in UI
        updateContactBadge(chatId, 0);
        
    } catch (error) {
        console.error('Error marking chat as read:', error);
    }
}

// Update individual contact badge
function updateContactBadge(chatId, unreadCount) {
    // Update in contacts list
    const contactElement = document.querySelector(`[data-chat-id="${chatId}"]`);
    if (contactElement) {
        const existingBadge = contactElement.querySelector('.unread-count');
        if (existingBadge) {
            if (unreadCount > 0) {
                existingBadge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
            } else {
                existingBadge.remove();
            }
        } else if (unreadCount > 0) {
            const contactStatus = contactElement.querySelector('.contact-status');
            if (contactStatus) {
                const unreadBadge = document.createElement('div');
                unreadBadge.className = 'unread-count';
                unreadBadge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
                contactStatus.appendChild(unreadBadge);
            }
        }
    }
    
    // Special handling for admin contact
    if (chatId.startsWith('support_student_')) {
        updateAdminContactBadge(unreadCount);
    }
}

// Update contact unread count in local state
function updateContactUnreadCount(chatId, unreadCount) {
    const oldCount = chatUnreadCounts[chatId] || 0;
    chatUnreadCounts[chatId] = unreadCount;
    
    // Update total count
    unreadMessagesCount = unreadMessagesCount - oldCount + unreadCount;
    updateUnreadMessagesCount(unreadMessagesCount);
    
    // Update UI
    updateContactBadge(chatId, unreadCount);
}

// Enhanced updateUnreadMessagesCount for sidebar badge
function updateUnreadMessagesCount(count) {
    const unreadBadge = document.getElementById('unreadMessagesCount');
    if (unreadBadge) {
        if (count > 0) {
            unreadBadge.textContent = count > 99 ? '99+' : count.toString();
            unreadBadge.style.display = 'inline';
            
            // Add pulse animation for new messages
            unreadBadge.style.animation = 'none';
            setTimeout(() => {
                unreadBadge.style.animation = 'pulse 1s ease-in-out';
            }, 10);
        } else {
            unreadBadge.style.display = 'none';
        }
    }
    
    // Also update the menu item text if needed
    updateChatMenuItemCount(count);
}

// Update chat menu item with count
function updateChatMenuItemCount(count) {
    const chatMenuItem = document.querySelector('a[data-section="chat"]');
    if (chatMenuItem) {
        const menuText = chatMenuItem.querySelector('span');
        if (menuText) {
            // Remove existing count from text
            const baseText = menuText.textContent.replace(/\(\d+\)\s*/, '');
            if (count > 0) {
                menuText.textContent = `${baseText} (${count})`;
            } else {
                menuText.textContent = baseText;
            }
        }
    }
}

// Enhanced real-time unread message tracking
function setupRealtimeUnreadListeners() {
    const studentId = auth.currentUser.uid;
    
    // Listen for chat updates to track unread messages in real-time
    const unreadListener = db.collection('chats')
        .where('participants', 'array-contains', studentId)
        .onSnapshot((snapshot) => {
            let totalUnread = 0;
            
            snapshot.docChanges().forEach((change) => {
                if (change.type === 'modified') {
                    const chat = change.doc.data();
                    const unreadCount = chat.unreadCounts?.[studentId] || 0;
                    const chatId = change.doc.id;
                    
                    // Update local state
                    const oldCount = chatUnreadCounts[chatId] || 0;
                    chatUnreadCounts[chatId] = unreadCount;
                    
                    // Only update total if the count actually changed
                    if (oldCount !== unreadCount) {
                        totalUnread += unreadCount;
                        
                        // Update individual contact badge
                        updateContactBadge(chatId, unreadCount);
                    }
                }
            });
            
            // Update total if we found changes
            if (totalUnread > 0) {
                unreadMessagesCount = Object.values(chatUnreadCounts).reduce((sum, count) => sum + count, 0);
                updateUnreadMessagesCount(unreadMessagesCount);
            }
        }, (error) => {
            console.error('Error in unread messages listener:', error);
        });
    
    return unreadListener;
}

// Enhanced initialization with unread tracking
function initChatSystem() {
    if (chatSystemInitialized) {
        console.log('Chat system already initialized');
        return;
    }
    
    console.log('Initializing chat system with enhanced unread tracking...');
    chatSystemInitialized = true;
    
    setupChatEventListeners();
    loadChatContacts();
    setupRealtimeListeners();
    
    // Start enhanced unread tracking
    setupRealtimeUnreadListeners();
}

// Get total unread messages count (for external use)
function getTotalUnreadMessages() {
    return unreadMessagesCount;
}

// Get unread count for specific chat
function getChatUnreadCount(chatId) {
    return chatUnreadCounts[chatId] || 0;
}

// Force refresh unread counts (useful after coming back online)
async function refreshUnreadCounts() {
    console.log('Refreshing unread message counts...');
    loadChatContacts();
}

// Initialize unread tracking when coming online
window.addEventListener('online', refreshUnreadCounts);

// Export functions for global access
window.getTotalUnreadMessages = getTotalUnreadMessages;
window.getChatUnreadCount = getChatUnreadCount;
window.refreshUnreadCounts = refreshUnreadCounts;
  
// =======================================================
// CHATS SECTION/MESSAGES SECTION ENDS HERE
// =======================================================

// =========================================================
// REVIEWS AND RATINGS START HERE
// ==========================================================

// Global variables for review pagination
let currentPendingPage = 1;
let currentSubmittedPage = 1;
const REVIEWS_PER_PAGE = 10;
let allPendingSessions = [];
let allSubmittedReviews = [];

// Load reviews with pagination
function loadReviewsSection() {
    loadPendingReviews();
    loadSubmittedReviews();
}

// Pending Reviews - Limited to 10 visible
function loadPendingReviews() {
    const container = document.getElementById('pendingReviewsContainer');
    const studentId = auth.currentUser.uid;
    const now = new Date();
    const cutoffTime = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days ago

    // Get all sessions from last 30 days that have ended
    db.collection('bookedSessions')
        .where('studentId', '==', studentId)
        .where('date', '<', now) // Past sessions only
        .where('date', '>=', cutoffTime) // Last 30 days only
        .orderBy('date', 'desc')
        .get()
        .then(snapshot => {
            allPendingSessions = [];
            snapshot.forEach(doc => {
                const session = {
                    id: doc.id,
                    ...doc.data()
                };
                
                // Check if this session should be available for review
                const isReviewable = isSessionReviewable(session);
                
                if (isReviewable) {
                    allPendingSessions.push(session);
                }
            });

            // AUTO-CLEANUP: Only show most recent 20 total
            if (allPendingSessions.length > 20) {
                allPendingSessions = allPendingSessions.slice(0, 20);
            }

            updatePendingReviewsDisplay();
            updatePendingReviewsCount();
        })
        .catch(error => {
            console.error('Error loading pending reviews:', error);
            container.innerHTML = getReviewsErrorState();
        });
}

// Helper function to determine if session is reviewable
function isSessionReviewable(session) {
    const now = new Date();
    const sessionEndTime = new Date(session.date.toDate().getTime() + (session.duration * 60 * 60 * 1000));
    
    // Session must be in the past (ended)
    if (sessionEndTime > now) {
        return false;
    }
    
    // If reviewStatus exists, only include if it's pending
    if (session.reviewStatus) {
        return session.reviewStatus === 'pending';
    }
    
    // If no reviewStatus field exists, check if we should create it
    // Include sessions that are confirmed/completed and past their end time
    const validStatuses = ['confirmed', 'completed', 'rescheduled'];
    return validStatuses.includes(session.status);
}

// Function to initialize reviewStatus for existing sessions
async function initializeReviewStatus() {
    const studentId = auth.currentUser.uid;
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));

    try {
        const snapshot = await db.collection('bookedSessions')
            .where('studentId', '==', studentId)
            .where('date', '>=', thirtyDaysAgo)
            .where('date', '<', now)
            .get();

        const batch = db.batch();
        let updateCount = 0;

        snapshot.forEach(doc => {
            const session = doc.data();
            
            // Only update if reviewStatus doesn't exist and session is in a reviewable state
            if (!session.reviewStatus && 
                ['confirmed', 'completed', 'rescheduled'].includes(session.status)) {
                
                batch.update(doc.ref, {
                    reviewStatus: 'pending',
                    lastUpdated: new Date()
                });
                updateCount++;
            }
        });

        if (updateCount > 0) {
            await batch.commit();
            console.log(`Initialized reviewStatus for ${updateCount} sessions`);
        }
        
        return updateCount;
    } catch (error) {
        console.error('Error initializing reviewStatus:', error);
        return 0;
    }
}

function editReview(reviewId) {
    // Find the review in submitted reviews
    const review = allSubmittedReviews.find(r => r.id === reviewId);
    if (!review) {
        console.error('Review not found:', reviewId);
        return;
    }

    // Create edit modal
    const modalHTML = `
        <div class="review-modal-overlay" id="editReviewModalOverlay">
            <div class="review-modal">
                <div class="modal-header">
                    <h3>Edit Your Review</h3>
                    <button class="close-btn" onclick="closeEditReviewModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="session-info">
                        <h4>${review.subject || 'Tutoring Session'}</h4>
                        <p>with ${review.tutorName || 'Your Tutor'}</p>
                        <p class="session-date">Originally reviewed on ${review.createdAt.toDate().toLocaleDateString()}</p>
                    </div>
                    
                    <div class="rating-section">
                        <label>Overall Rating:</label>
                        <div class="star-rating" id="editStarRating">
                            ${[1,2,3,4,5].map(star => `
                                <span class="star ${star <= review.rating ? 'active' : ''}" 
                                      data-rating="${star}" 
                                      onclick="setEditRating(${star})">★</span>
                            `).join('')}
                        </div>
                        <div class="rating-text" id="editRatingText">
                            ${getRatingText(review.rating)}
                        </div>
                    </div>
                    
                    <div class="review-text-section">
                        <label for="editReviewText">Your Review:</label>
                        <textarea 
                            id="editReviewText" 
                            placeholder="Share details about your experience. What went well? What could be improved?"
                            rows="4"
                        >${review.reviewText || ''}</textarea>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn-primary" onclick="updateReview('${reviewId}', '${review.tutorId}')" id="updateReviewBtn">
                        Update Review
                    </button>
                    <button class="btn-danger" onclick="deleteReview('${reviewId}')">
                        <i class="fas fa-trash"></i> Delete Review
                    </button>
                    <button class="btn-outline" onclick="closeEditReviewModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    window.currentEditRating = review.rating;
}

function setEditRating(rating) {
    const stars = document.querySelectorAll('#editStarRating .star');
    const ratingText = document.getElementById('editRatingText');
    
    stars.forEach((star, index) => {
        if (index < rating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
    
    ratingText.textContent = getRatingText(rating);
    window.currentEditRating = rating;
}

function getRatingText(rating) {
    const ratingTexts = {
        1: 'Poor',
        2: 'Fair', 
        3: 'Good',
        4: 'Very Good',
        5: 'Excellent'
    };
    return ratingTexts[rating] || 'Tap stars to rate';
}

  async function updateReview(reviewId, tutorId) {
    const rating = window.currentEditRating;
    const reviewText = document.getElementById('editReviewText').value.trim();
    const updateBtn = document.getElementById('updateReviewBtn');
    
    if (!rating) {
        alert('Please select a rating');
        return;
    }
    
    try {
        updateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Updating...';
        updateBtn.disabled = true;
        
      
      // Update the review
        await db.collection('ratings_reviews').doc(reviewId).update({
            rating: rating,
            reviewText: reviewText,
            updatedAt: new Date()
        });
        
        // Update tutor's average rating
        await updateTutorRating(tutorId);
        
        // Close modal and refresh reviews
        closeEditReviewModal();
        loadReviewsSection();
        
        showToast('Review updated successfully!', 'success');
        
    } catch (error) {
        console.error('Error updating review:', error);
        alert('Failed to update review. Please try again.');
        updateBtn.innerHTML = 'Update Review';
        updateBtn.disabled = false;
    }
}

async function deleteReview(reviewId) {
    if (!confirm('Are you sure you want to delete this review? This action cannot be undone.')) {
        return;
    }
    
    try {
        // Get review data first to update tutor rating later
        const reviewDoc = await db.collection('ratings_reviews').doc(reviewId).get();
        const reviewData = reviewDoc.data();
        
        // Delete the review
        await db.collection('ratings_reviews').doc(reviewId).delete();
        
        // Also update the session's review status back to pending
        if (reviewData.sessionId) {
            await db.collection('bookedSessions').doc(reviewData.sessionId).update({
                reviewStatus: 'pending',
                reviewedAt: null
            });
        }
        
        // Update tutor's average rating
        await updateTutorRating(reviewData.tutorId);
        
        // Close modal and refresh
        closeEditReviewModal();
        loadReviewsSection();
        
        showToast('Review deleted successfully!', 'success');
        
    } catch (error) {
        console.error('Error deleting review:', error);
        alert('Failed to delete review. Please try again.');
    }
}

  function closeEditReviewModal() {
    const modal = document.getElementById('editReviewModalOverlay');
    if (modal) {
        modal.remove();
    }
    window.currentEditRating = null;
}

// Also update your existing close function for consistency
function closeReviewModal() {
    const modal = document.getElementById('reviewModalOverlay');
    if (modal) {
        modal.remove();
    }
    window.currentRating = null;
}
  
// Update display with pagination
function updatePendingReviewsDisplay() {
    const container = document.getElementById('pendingReviewsContainer');
    const totalPages = Math.ceil(allPendingSessions.length / REVIEWS_PER_PAGE);
    
    // Get current page items
    const startIndex = (currentPendingPage - 1) * REVIEWS_PER_PAGE;
    const endIndex = startIndex + REVIEWS_PER_PAGE;
    const currentSessions = allPendingSessions.slice(startIndex, endIndex);

    if (currentSessions.length === 0) {
        container.innerHTML = getPendingReviewsEmptyState();
        return;
    }

    let html = '';
    
    currentSessions.forEach(session => {
        const sessionDate = session.date.toDate();
        const formattedDate = sessionDate.toLocaleDateString();
        const formattedTime = sessionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        html += `
            <div class="review-card pending">
                <div class="review-header">
                    <div class="review-tutor-info">
                        <h5>${session.subject || 'Tutoring Session'}</h5>
                        <div class="review-session-meta">
                            <i class="fas fa-user-tie"></i> ${session.tutorName || 'Tutor'} • 
                            <i class="fas fa-calendar"></i> ${formattedDate} • 
                            <i class="fas fa-clock"></i> ${formattedTime}
                        </div>
                    </div>
                    <div class="session-duration">
                        ${session.duration || '1'} hour${session.duration !== 1 ? 's' : ''}
                    </div>
                </div>
                
                <div class="review-actions">
                    <button class="btn-primary" onclick="showReviewModal('${session.id}')">
                        <i class="fas fa-star"></i> Write Review
                    </button>
                    <button class="btn-outline" onclick="dismissReview('${session.id}')">
                        <i class="fas fa-times"></i> Dismiss
                    </button>
                </div>
            </div>
        `;
    });

    // Add pagination if needed
    if (totalPages > 1) {
        html += createReviewsPagination('pending', currentPendingPage, totalPages);
    }

    container.innerHTML = html;
}

// Submitted Reviews - Limited to 10 visible
function loadSubmittedReviews() {
    const container = document.getElementById('submittedReviewsContainer');
    const studentId = auth.currentUser.uid;

    db.collection('ratings_reviews')
        .where('studentId', '==', studentId)
        .orderBy('createdAt', 'desc')
        .limit(50) // Maximum fetch limit
        .get()
        .then(snapshot => {
            allSubmittedReviews = [];
            snapshot.forEach(doc => {
                allSubmittedReviews.push({
                    id: doc.id,
                    ...doc.data()
                });
            });

            // AUTO-CLEANUP: Only keep 30 most recent reviews in memory
            if (allSubmittedReviews.length > 30) {
                allSubmittedReviews = allSubmittedReviews.slice(0, 30);
            }

            updateSubmittedReviewsDisplay();
        })
        .catch(error => {
            console.error('Error loading submitted reviews:', error);
            container.innerHTML = getReviewsErrorState();
        });
}

function updateSubmittedReviewsDisplay() {
    const container = document.getElementById('submittedReviewsContainer');
    const totalPages = Math.ceil(allSubmittedReviews.length / REVIEWS_PER_PAGE);
    
    const startIndex = (currentSubmittedPage - 1) * REVIEWS_PER_PAGE;
    const endIndex = startIndex + REVIEWS_PER_PAGE;
    const currentReviews = allSubmittedReviews.slice(startIndex, endIndex);

    if (currentReviews.length === 0) {
        container.innerHTML = getSubmittedReviewsEmptyState();
        return;
    }

    let html = '';
    
    currentReviews.forEach(review => {
        const reviewDate = review.createdAt.toDate();
        const formattedDate = reviewDate.toLocaleDateString();
        const hasResponse = review.tutorResponse && review.tutorResponse.trim() !== '';
        const responseDate = hasResponse && review.respondedAt ? review.respondedAt.toDate().toLocaleDateString() : '';
        
        html += `
            <div class="review-card submitted">
                <div class="review-header">
                    <div class="review-tutor-info">
                        <h5>${review.tutorName || 'Tutor'}</h5>
                        <div class="review-session-meta">
                            <i class="fas fa-calendar"></i> Reviewed on ${formattedDate}
                        </div>
                    </div>
                    <div class="star-rating-static">
                        ${generateStaticStars(review.rating)}
                    </div>
                </div>
                
                ${review.reviewText ? `
                    <div class="review-text">"${review.reviewText}"</div>
                ` : ''}
                
                <!-- Tutor Response Section -->
                ${hasResponse ? `
                    <div class="tutor-response-section">
                        <div class="response-header">
                            <i class="fas fa-reply"></i>
                            <strong>Response from ${review.tutorName || 'Tutor'}</strong>
                            ${responseDate ? `<span class="response-date">on ${responseDate}</span>` : ''}
                        </div>
                        <div class="response-text">${review.tutorResponse}</div>
                    </div>
                ` : `
                    <div class="no-response-message">
                        <i class="fas fa-clock"></i>
                        <span>No response from tutor yet</span>
                    </div>
                `}
                
                <div class="review-meta">
                    <span>Session: ${review.subject || 'General'}</span>
                    <button class="btn-outline btn-small" onclick="editReview('${review.id}')">
                        <i class="fas fa-edit"></i> Edit Review
                    </button>
                </div>
            </div>
        `;
    });

    if (totalPages > 1) {
        html += createReviewsPagination('submitted', currentSubmittedPage, totalPages);
    }

    container.innerHTML = html;
}
  
function handleReviewError(error, action) {
    console.error(`Error ${action} review:`, error);
    
    let message = `Failed to ${action} review. `;
    if (error.code === 'permission-denied') {
        message += 'You do not have permission to perform this action.';
    } else if (error.code === 'not-found') {
        message += 'Review not found. It may have been deleted.';
    } else {
        message += 'Please try again.';
    }
    
    alert(message);
}

  
// Pagination Helper
function createReviewsPagination(type, currentPage, totalPages) {
    return `
        <div class="reviews-pagination">
            <button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} 
                onclick="changeReviewsPage('${type}', ${currentPage - 1})">
                <i class="fas fa-chevron-left"></i> Previous
            </button>
            
            <span class="pagination-info">Page ${currentPage} of ${totalPages}</span>
            
            <button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''}
                onclick="changeReviewsPage('${type}', ${currentPage + 1})">
                Next <i class="fas fa-chevron-right"></i>
            </button>
        </div>
    `;
}

function changeReviewsPage(type, newPage) {
    if (type === 'pending') {
        currentPendingPage = newPage;
        updatePendingReviewsDisplay();
    } else {
        currentSubmittedPage = newPage;
        updateSubmittedReviewsDisplay();
    }
}

// Auto-cleanup older sessions (runs periodically)
function cleanupOldPendingSessions() {
    const thirtyDaysAgo = new Date(Date.now() - (30 * 24 * 60 * 60 * 1000));
    
    // Auto-mark very old pending reviews as dismissed
    db.collection('bookedSessions')
        .where('studentId', '==', auth.currentUser.uid)
        .where('status', '==', 'completed')
        .where('reviewStatus', '==', 'pending')
        .where('date', '<', thirtyDaysAgo)
        .get()
        .then(snapshot => {
            const batch = db.batch();
            snapshot.forEach(doc => {
                batch.update(doc.ref, {
                    reviewStatus: 'auto_dismissed',
                    dismissedAt: new Date()
                });
            });
            return batch.commit();
        })
        .then(() => {
            console.log(`Auto-dismissed ${snapshot.size} old pending reviews`);
        });
}

// Run cleanup every hour
setInterval(cleanupOldPendingSessions, 60 * 60 * 1000);

// Star rating generation
function generateStaticStars(rating) {
    let stars = '';
    const fullStars = Math.floor(rating);
    const hasHalfStar = rating % 1 !== 0;
    
    // Full stars
    for (let i = 0; i < fullStars; i++) {
        stars += '<i class="fas fa-star"></i>';
    }
    
    // Half star
    if (hasHalfStar) {
        stars += '<i class="fas fa-star-half-alt"></i>';
    }
    
    // Empty stars
    const emptyStars = 5 - Math.ceil(rating);
    for (let i = 0; i < emptyStars; i++) {
        stars += '<i class="far fa-star"></i>';
    }
    
    return stars;
}

// Review modal functions
function showReviewModal(sessionId, sessionData = null) {
    // If sessionData not provided, fetch it
    if (!sessionData) {
        db.collection('bookedSessions').doc(sessionId).get()
            .then(doc => {
                if (doc.exists) {
                    showReviewModal(sessionId, doc.data());
                }
            });
        return;
    }
    
    // Create and show modal
    const modalHTML = `
        <div class="review-modal-overlay" id="reviewModalOverlay">
            <div class="review-modal">
                <div class="modal-header">
                    <h3>Rate Your Session</h3>
                    <button class="close-btn" onclick="closeReviewModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="session-info">
                        <h4>${sessionData.subject || 'Tutoring Session'}</h4>
                        <p>with ${sessionData.tutorName || 'Your Tutor'}</p>
                        <p class="session-date">${sessionData.date.toDate().toLocaleDateString()}</p>
                    </div>
                    
                    <div class="rating-section">
                        <label>Overall Rating:</label>
                        <div class="star-rating" id="starRating">
                            ${[1,2,3,4,5].map(star => `
                                <span class="star" data-rating="${star}" onclick="setRating(${star})">★</span>
                            `).join('')}
                        </div>
                        <div class="rating-text" id="ratingText">Tap stars to rate</div>
                    </div>
                    
                    <div class="review-text-section">
                        <label for="reviewText">Your Review (Optional):</label>
                        <textarea 
                            id="reviewText" 
                            placeholder="Share details about your experience. What went well? What could be improved?"
                            rows="4"
                        ></textarea>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn-primary" onclick="submitReview('${sessionId}', '${sessionData.tutorId}')" id="submitReviewBtn" disabled>
                        Submit Review
                    </button>
                    <button class="btn-outline" onclick="dismissReview('${sessionId}')">
                        Dismiss
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function setRating(rating) {
    const stars = document.querySelectorAll('#starRating .star');
    const ratingText = document.getElementById('ratingText');
    const submitBtn = document.getElementById('submitReviewBtn');
    
    stars.forEach((star, index) => {
        if (index < rating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
    
    // Update rating text
    const ratingTexts = {
        1: 'Poor',
        2: 'Fair', 
        3: 'Good',
        4: 'Very Good',
        5: 'Excellent'
    };
    
    ratingText.textContent = ratingTexts[rating] || 'Tap stars to rate';
    
    // Enable submit button
    submitBtn.disabled = false;
    
    // Store current rating
    window.currentRating = rating;
}

async function submitReview(sessionId, tutorId) {
    const rating = window.currentRating;
    const reviewText = document.getElementById('reviewText').value.trim();
    const submitBtn = document.getElementById('submitReviewBtn');
    
    if (!rating) {
        alert('Please select a rating');
        return;
    }
    
    try {
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
        submitBtn.disabled = true;
        
        // Get session data
        const sessionDoc = await db.collection('bookedSessions').doc(sessionId).get();
        const sessionData = sessionDoc.data();
        
        // Save to ratings_reviews collection
        await db.collection('ratings_reviews').add({
            sessionId: sessionId,
            tutorId: tutorId,
            studentId: auth.currentUser.uid,
            studentName: userData?.name || 'Student',
            tutorName: sessionData.tutorName,
            rating: rating,
            reviewText: reviewText,
            createdAt: new Date(),
            subject: sessionData?.subject || 'General Tutoring'
        });
        
        // Update session review status (create field if it doesn't exist)
        await db.collection('bookedSessions').doc(sessionId).update({
            reviewStatus: 'completed',
            reviewedAt: new Date(),
            lastUpdated: new Date()
        });
        
        // Update tutor's average rating
        await updateTutorRating(tutorId);
        
        // Close modal and refresh
        closeReviewModal();
        loadReviewsSection();
        
        showToast('Review submitted successfully!', 'success');
        
    } catch (error) {
        console.error('Error submitting review:', error);
        alert('Failed to submit review. Please try again.');
        submitBtn.innerHTML = 'Submit Review';
        submitBtn.disabled = false;
    }
}
  
// MAKE SURE updateTutorRating is async!
async function updateTutorRating(tutorId) {
    try {
        const reviewsSnapshot = await db.collection('ratings_reviews')
            .where('tutorId', '==', tutorId)
            .get();
        
        let totalRating = 0;
        let reviewCount = 0;
        
        reviewsSnapshot.forEach(doc => {
            const review = doc.data();
            totalRating += review.rating;
            reviewCount++;
        });
        
        const averageRating = reviewCount > 0 ? totalRating / reviewCount : 0;
        
        // Update tutor document
        await db.collection('tutors').doc(tutorId).update({
            rating: Math.round(averageRating * 2) / 2, // Round to nearest 0.5
            reviewCount: reviewCount
        });
    } catch (error) {
        console.error('Error updating tutor rating:', error);
        // Don't throw - we don't want to fail the whole review if this fails
    }
}
  
function dismissReview(sessionId) {
    if (confirm('Are you sure you want to dismiss this review? You won\'t be prompted again.')) {
        db.collection('bookedSessions').doc(sessionId).update({
            reviewStatus: 'dismissed',
            dismissedAt: new Date()
        }).then(() => {
            closeReviewModal();
            loadReviewsSection();
        });
    }
}

function closeReviewModal() {
    const modal = document.getElementById('reviewModalOverlay');
    if (modal) {
        modal.remove();
    }
    window.currentRating = null;
}

// Update pending reviews count badge
function updatePendingReviewsCount() {
    const badge = document.getElementById('pendingReviewsCount');
    if (!badge) return;
    
    const count = allPendingSessions.length;
    if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count.toString();
        badge.style.display = 'inline';
    } else {
        badge.style.display = 'none';
    }
}

// Empty state templates
function getPendingReviewsEmptyState() {
    return `
        <div class="reviews-empty-state">
            <i class="fas fa-check-circle"></i>
            <h4>All Caught Up!</h4>
            <p>No pending reviews. Your feedback helps tutors improve.</p>
        </div>
    `;
}

function getSubmittedReviewsEmptyState() {
    return `
        <div class="reviews-empty-state">
            <i class="fas fa-star"></i>
            <h4>No Reviews Yet</h4>
            <p>Your completed session reviews will appear here</p>
        </div>
    `;
}

function getReviewsErrorState() {
    return `
        <div class="error-state">
            <i class="fas fa-exclamation-triangle"></i>
            <h3>Error Loading Reviews</h3>
            <p>Please try again later</p>
        </div>
    `;
}

// Update tutor rating (simplified - you'll need a Cloud Function for accurate averaging)
async function updateTutorRating(tutorId) {
    // This is a simplified version - you should use a Cloud Function
    // to properly calculate the average rating
    
    const reviewsSnapshot = await db.collection('ratings_reviews')
        .where('tutorId', '==', tutorId)
        .get();
    
    let totalRating = 0;
    let reviewCount = 0;
    
    reviewsSnapshot.forEach(doc => {
        const review = doc.data();
        totalRating += review.rating;
        reviewCount++;
    });
    
    const averageRating = reviewCount > 0 ? totalRating / reviewCount : 0;
    
    // Update tutor document
    await db.collection('tutors').doc(tutorId).update({
        rating: Math.round(averageRating * 2) / 2, // Round to nearest 0.5
        reviewCount: reviewCount
    });
}

// Toast notification
function showToast(message, type = 'info') {
    // Use your existing notification system or create a simple one
    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type}`;
    toast.innerHTML = `
        <div class="toast-content">
            <i class="fas fa-${type === 'success' ? 'check-circle' : 'info-circle'}"></i>
            <span>${message}</span>
        </div>
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.remove();
    }, 3000);
}

// Initialize reviews when section is opened
document.addEventListener('DOMContentLoaded', function() {
    document.addEventListener('click', function(e) {
        if (e.target.closest('a[data-section="reviews"]')) {
            // Initialize missing reviewStatus fields first, then load reviews
            initializeReviewStatus().then(() => {
                loadReviewsSection();
            }).catch(() => {
                // If initialization fails, still try to load reviews
                loadReviewsSection();
            });
        }
    });
});

  async function debugReviewSessions() {
    const studentId = auth.currentUser.uid;
    const now = new Date();
    const cutoffTime = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));

    const snapshot = await db.collection('bookedSessions')
        .where('studentId', '==', studentId)
        .where('date', '<', now)
        .where('date', '>=', cutoffTime)
        .orderBy('date', 'desc')
        .get();

    console.log('=== REVIEW DEBUG INFO ===');
    console.log(`Found ${snapshot.size} sessions in date range`);
    
    snapshot.forEach(doc => {
        const session = doc.data();
        const sessionDate = session.date.toDate();
        const sessionEnd = new Date(sessionDate.getTime() + (parseInt(session.duration) * 60 * 60 * 1000));
        const isEnded = sessionEnd < now;
        
        console.log(`Session: ${doc.id}`, {
            date: sessionDate.toLocaleString(),
            endTime: sessionEnd.toLocaleString(),
            subject: session.subject,
            status: session.status,
            reviewStatus: session.reviewStatus || 'MISSING',
            isPast: sessionDate < now,
            isEnded: isEnded,
            duration: session.duration,
            isReviewable: isSessionReviewable(session)
        });
    });
}

// Call this to see what sessions should be reviewable
// debugReviewSessions();
  
 // =========================================================
// REVIEWS AND RATINGS END HERE
// ========================================================== 
  
  
</script>    
</body>
</html>




